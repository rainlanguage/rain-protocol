{
  "language": "Solidity",
  "sources": {
    "contracts/claim/TierByConstructionClaim.sol": {
      "content": "// SPDX-License-Identifier: CAL\n\npragma solidity 0.6.12;\n\nimport { ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport { ITier } from \"../tier/ITier.sol\";\nimport { TierByConstruction } from \"../tier/TierByConstruction.sol\";\n\n/// @title TierByConstructionClaim\n/// @notice `TierByConstructionClaim` is a base contract for other contracts to\n/// inherit from.\n///\n/// It builds on `TierByConstruction` with a `claim` function and `_afterClaim`\n/// hook.\n///\n/// The `claim` function checks `onlyTier` and exposes `isTier` for\n/// `_afterClaim` hooks so that accounts can self-mint rewards such as erc20,\n/// erc1155, erc721, etc. if they meet the tier requirements.\n///\n/// The `claim` function can only be called once per account.\n///\n/// Note that `claim` is an unrestricted function and only the tier of the\n/// _recipient_ is checked.\n///\n/// Implementing contracts must be careful to avoid griefing attacks where an\n/// attacker calls `claim` against a third party in such a way that their\n/// reward is minimised or damaged in some way.\n///\n/// For example, `ERC20BalanceTier` used with `TierByConstructionClaim` opens\n/// the ability for an attacker to `claim` every address they know that has not\n/// reached the minimum balance, permanently voiding that address for future\n/// claims even if they reach the minimum balance at a later date.\n///\n/// Another example, `data_` is set to some empty value by the attacker for the\n/// `claim` call that voids the ability for the recipient to receive more\n/// rewards, had the `data_` been set to some meaningful value.\n///\n/// The simplest fix is to require `msg.sender` and recipient account are the\n/// same, thus requiring the receiver to ensure for themselves that they claim\n/// only when and how they want. Of course, this also precludes a whole class\n/// of delegated claims processing that may provide a superior user experience.\n///\n/// Inheriting contracts MUST implement `_afterClaim` with restrictions that\n/// are appropriate to the nature of the claim.\n///\n/// @dev Contract that can be inherited by anything that wants to manage claims\n/// of erc20/721/1155/etc. based on tier.\n/// The tier must be held continously since the contract construction according\n/// to the tier contract.\n/// In general it is INSECURE to inherit `TierByConstructionClaim` without\n/// implementing `_afterClaim` with appropriate access checks.\ncontract TierByConstructionClaim is TierByConstruction {\n    /// The minimum tier required for an address to claim anything at all.\n    /// This tier must have been held continuously since before this\n    /// contract was constructed.\n    ITier.Tier public immutable minimumTier;\n\n    /// Tracks every address that has already claimed to prevent duplicate\n    /// claims.\n    mapping(address => bool) public claims;\n\n    /// A claim has been successfully processed for an account.\n    event Claim(address indexed account, bytes data);\n\n    /// Nothing special needs to happen in the constructor.\n    /// Simply forwards the desired ITier contract to the `TierByConstruction`\n    /// constructor.\n    /// The minimum tier is set for `claim` logic.\n    constructor(ITier tierContract_, ITier.Tier minimumTier_)\n        public\n        TierByConstruction(tierContract_)\n    {\n        minimumTier = minimumTier_;\n    }\n\n    /// The `onlyTier` modifier checks the claimant against minimumTier.\n    /// The ITier contract decides for itself whether the claimant is\n    /// `minimumTier` __as at the block this contract was constructed__.\n    /// This may be ambiguous for `ReadOnlyTier` contracts that may not have\n    /// accurate block times and fallback to `0` when the block is unknown.\n    ///\n    /// If `account_` gained `minimumTier` after this contract was deployed\n    /// but hold it at the time of calling `claim` they are NOT eligible.\n    ///\n    /// The claim can only be called successfully once per account.\n    ///\n    /// NOTE: This function is callable by anyone and can only be\n    /// called at most once per account.\n    /// The `_afterClaim` function can and MUST enforce all appropriate access\n    /// restrictions on when/how a claim is valid.\n    ///\n    /// Be very careful to manage griefing attacks when the `msg.sender` is not\n    /// `account_`, for example:\n    /// - An `ERC20BalanceTier` has no historical information so\n    /// anyone can claim for anyone else based on their balance at any time.\n    /// - `data_` may be set arbitrarily by `msg.sender` so could be\n    /// consumed frivilously at the expense of `account_`.\n    ///\n    /// @param account_ The account that receives the benefits of the claim.\n    /// @param data_ Additional data that may inform the claim process.\n    function claim(address account_, bytes memory data_)\n        external\n        onlyTier(account_, minimumTier)\n    {\n        // Prevent duplicate claims for a given account.\n        require(!claims[account_], \"DUPLICATE_CLAIM\");\n\n        // Record that a claim has been made for this account.\n        claims[account_] = true;\n\n        // Log the claim.\n        emit Claim(account_, data_);\n\n        // Process the claim.\n        // Inheriting contracts will need to override this to make\n        // the claim useful.\n        _afterClaim(account_, tierContract.report(account_), data_);\n    }\n\n    /// Implementing contracts need to define what is claimed.\n    // Slither false positive. This is intended to overridden.\n    // https://github.com/crytic/slither/issues/929\n    // slither-disable-next-line dead-code\n    function _afterClaim(\n        address account_,\n        uint256 report_,\n        bytes memory data_\n    )\n        internal virtual\n    { } // solhint-disable-line no-empty-blocks\n}"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../../GSN/Context.sol\";\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20 {\n    using SafeMath for uint256;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\n     * a default value of 18.\n     *\n     * To select a different value for {decimals}, use {_setupDecimals}.\n     *\n     * All three of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor (string memory name_, string memory symbol_) public {\n        _name = name_;\n        _symbol = symbol_;\n        _decimals = 18;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\n     * called.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Sets {decimals} to a value other than the default one of 18.\n     *\n     * WARNING: This function should only be called from the constructor. Most\n     * applications that interact with token contracts will not expect\n     * {decimals} to ever change, and may work incorrectly if it does.\n     */\n    function _setupDecimals(uint8 decimals_) internal {\n        _decimals = decimals_;\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n}\n"
    },
    "contracts/tier/ITier.sol": {
      "content": "// SPDX-License-Identifier: CAL\n\npragma solidity 0.6.12;\n\n/// @title ITier\n/// @notice `ITier` is a simple interface that contracts can\n/// implement to provide membership lists for other contracts.\n///\n/// There are many use-cases for a time-preserving,\n/// conditional membership list.\n///\n/// Some examples include:\n///\n/// - Self-serve whitelist to participate in fundraising\n/// - Lists of users who can claim airdrops and perks\n/// - Pooling resources with implied governance/reward tiers\n/// - POAP style attendance proofs allowing access to future exclusive events\n///\n/// @dev Standard interface to a tiered membership.\n///\n/// A \"membership\" can represent many things:\n/// - Exclusive access.\n/// - Participation in some event or process.\n/// - KYC completion.\n/// - Combination of sub-memberships.\n/// - Etc.\n///\n/// The high level requirements for a contract implementing `ITier`:\n/// - MUST represent held tiers with the `Tier` enum.\n/// - MUST implement `report`.\n///   - The report is a `uint256` that SHOULD represent the block each tier has\n///     been continuously held since encoded as `uint32`.\n///   - The encoded tiers start at ONE; ZERO is implied if no tier has ever\n///     been held.\n///   - `Tier.ZERO` is NOT encoded in the report, it is simply the fallback\n///     value.\n///   - If a tier is lost the block data is erased for that tier and will be\n///     set if/when the tier is regained to the new block.\n///   - If the historical block information is not available the report MAY\n///     return `0x00000000` for all held tiers.\n///   - Tiers that are lost or have never been held MUST return `0xFFFFFFFF`.\n/// - SHOULD implement `setTier`.\n///   - Contracts SHOULD revert with `SET_TIER` error if they cannot\n///     meaningfully set a tier directly.\n///     For example a contract that can only derive a membership tier by\n///     reading the state of an external contract cannot set tiers.\n///   - Contracts implementing `setTier` SHOULD error with `SET_ZERO_TIER`\n///     if `Tier.ZERO` is being set.\n/// - MUST emit `TierChange` when `setTier` successfully writes a new tier.\n///   - Contracts that cannot meaningfully set a tier are exempt.\ninterface ITier {\n    /// 9 Possible tiers.\n    /// Fits nicely as uint32 in uint256 which is helpful for internal storage\n    /// concerns.\n    /// 8 tiers can be achieved, ZERO is the tier when no tier has been\n    /// achieved.\n    enum Tier {\n        ZERO,\n        ONE,\n        TWO,\n        THREE,\n        FOUR,\n        FIVE,\n        SIX,\n        SEVEN,\n        EIGHT\n    }\n\n    /// Every time a Tier changes we log start and end Tier against the\n    /// account.\n    /// This MAY NOT be emitted if reports are being read from the state of an\n    /// external contract.\n    event TierChange(\n        address indexed account,\n        Tier indexed startTier,\n        Tier indexed endTier\n    );\n\n    /// @notice Users can set their own tier by calling `setTier`.\n    ///\n    /// The contract that implements `ITier` is responsible for checking\n    /// eligibility and/or taking actions required to set the tier.\n    ///\n    /// For example, the contract must take/refund any tokens relevant to\n    /// changing the tier.\n    ///\n    /// Obviously the user is responsible for any approvals for this action\n    /// prior to calling `setTier`.\n    ///\n    /// When the tier is changed a `TierChange` event will be emmited as:\n    /// ```\n    /// event TierChange(address account, Tier startTier, Tier endTier);\n    /// ```\n    ///\n    /// The `setTier` function includes arbitrary data as the third\n    /// parameter. This can be used to disambiguate in the case that\n    /// there may be many possible options for a user to achieve some tier.\n    ///\n    /// For example, consider the case where `Tier.THREE` can be achieved\n    /// by EITHER locking 1x rare NFT or 3x uncommon NFTs. A user with both\n    /// could use `data` to explicitly state their intent.\n    ///\n    /// NOTE however that _any_ address can call `setTier` for any other\n    /// address.\n    ///\n    /// If you implement `data` or anything that changes state then be very\n    /// careful to avoid griefing attacks.\n    ///\n    /// The `data` parameter can also be ignored by the contract implementing\n    /// `ITier`. For example, ERC20 tokens are fungible so only the balance\n    /// approved by the user is relevant to a tier change.\n    ///\n    /// The `setTier` function SHOULD prevent users from reassigning\n    /// `Tier.ZERO` to themselves.\n    ///\n    /// The `Tier.ZERO` status represents never having any status.\n    /// @dev Updates the tier of an account.\n    ///\n    /// The implementing contract is responsible for all checks and state\n    /// changes required to set the tier. For example, taking/refunding\n    /// funds/NFTs etc.\n    ///\n    /// Contracts may disallow directly setting tiers, preferring to derive\n    /// reports from other onchain data.\n    /// In this case they should `revert(\"SET_TIER\");`.\n    ///\n    /// @param account Account to change the tier for.\n    /// @param endTier Tier after the change.\n    /// @param data Arbitrary input to disambiguate ownership\n    /// (e.g. NFTs to lock).\n    function setTier(\n        address account,\n        Tier endTier,\n        bytes memory data\n    )\n        external;\n\n    /// @notice A tier report is a `uint256` that contains each of the block\n    /// numbers each tier has been held continously since as a `uint32`.\n    /// There are 9 possible tier, starting with `Tier.ZERO` for `0` offset or\n    /// \"never held any tier\" then working up through 8x 4 byte offsets to the\n    /// full 256 bits.\n    ///\n    /// Low bits = Lower tier.\n    ///\n    /// In hexadecimal every 8 characters = one tier, starting at `Tier.EIGHT`\n    /// from high bits and working down to `Tier.ONE`.\n    ///\n    /// `uint32` should be plenty for any blockchain that measures block times\n    /// in seconds, but reconsider if deploying to an environment with\n    /// significantly sub-second block times.\n    ///\n    /// ~135 years of 1 second blocks fit into `uint32`.\n    ///\n    /// `2^8 / (365 * 24 * 60 * 60)`\n    ///\n    /// When a user INCREASES their tier they keep all the block numbers they\n    /// already had, and get new block times for each increased tiers they have\n    /// earned.\n    ///\n    /// When a user DECREASES their tier they return to `0xFFFFFFFF` (never)\n    /// for every tier level they remove, but keep their block numbers for the\n    /// remaining tiers.\n    ///\n    /// GUIs are encouraged to make this dynamic very clear for users as\n    /// round-tripping to a lower status and back is a DESTRUCTIVE operation\n    /// for block times.\n    ///\n    /// The intent is that downstream code can provide additional benefits for\n    /// members who have maintained a certain tier for/since a long time.\n    /// These benefits can be provided by inspecting the report, and by\n    /// on-chain contracts directly,\n    /// rather than needing to work with snapshots etc.\n    /// @dev Returns the earliest block the account has held each tier for\n    /// continuously.\n    /// This is encoded as a uint256 with blocks represented as 8x\n    /// concatenated uint32.\n    /// I.e. Each 4 bytes of the uint256 represents a u32 tier start time.\n    /// The low bits represent low tiers and high bits the high tiers.\n    /// Implementing contracts should return 0xFFFFFFFF for lost &\n    /// never-held tiers.\n    ///\n    /// @param account Account to get the report for.\n    /// @return The report blocks encoded as a uint256.\n    function report(address account) external view returns (uint256);\n}"
    },
    "contracts/tier/TierByConstruction.sol": {
      "content": "// SPDX-License-Identifier: CAL\n\npragma solidity 0.6.12;\n\nimport { TierUtil } from \"../libraries/TierUtil.sol\";\nimport { ITier } from \"./ITier.sol\";\n\n/// @title TierByConstruction\n/// @notice `TierByConstruction` is a base contract for other\n/// contracts to inherit from.\n///\n/// It exposes `isTier` and the corresponding modifier `onlyTier`.\n///\n/// This ensures that the address has held at least the given tier\n/// since the contract was constructed.\n///\n/// We check against the construction time of the contract rather\n/// than the current block to avoid various exploits.\n///\n/// Users should not be able to gain a tier for a single block, claim\n/// benefits then remove the tier within the same block.\n///\n/// The construction block provides a simple and generic reference\n/// point that is difficult to manipulate/predict.\n///\n/// Note that `ReadOnlyTier` contracts must carefully consider use\n/// with `TierByConstruction` as they tend to return `0x00000000` for\n/// any/all tiers held. There needs to be additional safeguards to\n/// mitigate \"flash tier\" attacks.\n///\n/// Note that an account COULD be `TierByConstruction` then lower/\n/// remove a tier, then no longer be eligible when they regain the\n/// tier. Only _continuously held_ tiers are valid against the\n/// construction block check as this is native behaviour of the\n/// `report` function in `ITier`.\n///\n/// Technically the `ITier` could re-enter the `TierByConstruction`\n/// so the `onlyTier` modifier runs AFTER the modified function.\n///\n/// @dev Enforces tiers held by contract contruction block.\n/// The construction block is compared against the blocks returned by `report`.\n/// The `ITier` contract is paramaterised and set during construction.\ncontract TierByConstruction {\n    ITier public tierContract;\n    uint256 public constructionBlock;\n\n    constructor(ITier tierContract_) public {\n        tierContract = tierContract_;\n        constructionBlock = block.number;\n    }\n\n    /// Check if an account has held AT LEAST the given tier according to\n    /// `tierContract` since construction.\n    /// The account MUST have held the tier continuously from construction\n    /// until the \"current\" state according to `report`.\n    /// Note that `report` PROBABLY is current as at the block this function is\n    /// called but MAYBE NOT.\n    /// The `ITier` contract is free to manage reports however makes sense.\n    ///\n    /// @param account_ Account to check status of.\n    /// @param minimumTier_ Minimum tier for the account.\n    /// @return True if the status is currently held.\n    function isTier(address account_, ITier.Tier minimumTier_)\n        public\n        view\n        returns (bool)\n    {\n        return constructionBlock >= TierUtil.tierBlock(\n            tierContract.report(account_),\n            minimumTier_\n        );\n    }\n\n    /// Modifier that restricts access to functions depending on the tier\n    /// required by the function.\n    ///\n    /// `isTier` involves an external call to tierContract.report.\n    /// `require` happens AFTER the modified function to avoid rentrant\n    /// `ITier` code.\n    /// Also `report` from `ITier` is `view` so the compiler will error on\n    /// attempted state modification.\n    // solhint-disable-next-line max-line-length\n    /// https://consensys.github.io/smart-contract-best-practices/recommendations/#use-modifiers-only-for-checks\n    ///\n    /// Do NOT use this to guard setting the tier on an `ITier` contract.\n    /// The initial tier would be checked AFTER it has already been\n    /// modified which is unsafe.\n    ///\n    /// @param account_ Account to enforce tier of.\n    /// @param minimumTier_ Minimum tier for the account.\n    modifier onlyTier(address account_, ITier.Tier minimumTier_) {\n        _;\n        require(\n            isTier(account_, minimumTier_),\n            \"MINIMUM_TIER\"\n        );\n    }\n}"
    },
    "@openzeppelin/contracts/GSN/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "contracts/libraries/TierUtil.sol": {
      "content": "// SPDX-License-Identifier: CAL\n\npragma solidity 0.6.12;\n\nimport { ITier } from \"../tier/ITier.sol\";\n\n/// @title TierUtil\n/// @notice `TierUtil` implements several pure functions that can be\n/// used to interface with reports.\n/// - `tierAtBlockFromReport`: Returns the highest status achieved relative to\n/// a block number and report. Statuses gained after that block are ignored.\n/// - `tierBlock`: Returns the block that a given tier has been held\n/// since according to a report.\n/// - `truncateTiersAbove`: Resets all the tiers above the reference tier.\n/// - `updateBlocksForTierRange`: Updates a report with a block\n/// number for every tier in a range.\n/// - `updateReportWithTierAtBlock`: Updates a report to a new tier.\n/// @dev Utilities to consistently read, write and manipulate tiers in reports.\n/// The low-level bit shifting can be difficult to get right so this factors\n/// that out.\nlibrary TierUtil {\n\n    /// UNINITIALIZED report is 0xFF.. as no tier has been held.\n    uint256 constant public UNINITIALIZED = uint256(-1);\n\n    /// Returns the highest tier achieved relative to a block number\n    /// and report.\n    ///\n    /// Note that typically the report will be from the _current_ contract\n    /// state, i.e. `block.number` but not always. Tiers gained after the\n    /// reference block are ignored.\n    ///\n    /// When the `report` comes from a later block than the `blockNumber` this\n    /// means the user must have held the tier continuously from `blockNumber`\n    /// _through_ to the report block.\n    /// I.e. NOT a snapshot.\n    ///\n    /// @param report_ A report as per `ITier`.\n    /// @param blockNumber_ The block number to check the tiers against.\n    /// @return The highest tier held since `blockNumber` as per `report`.\n    function tierAtBlockFromReport(\n        uint256 report_,\n        uint256 blockNumber_\n    )\n        internal pure returns (ITier.Tier)\n    {\n        for (uint256 i_ = 0; i_ < 8; i_++) {\n            if (uint32(uint256(report_ >> (i_*32))) > uint32(blockNumber_)) {\n                return ITier.Tier(i_);\n            }\n        }\n        return ITier.Tier(8);\n    }\n\n    /// Returns the block that a given tier has been held since from a report.\n    ///\n    /// The report MUST encode \"never\" as 0xFFFFFFFF. This ensures\n    /// compatibility with `tierAtBlockFromReport`.\n    ///\n    /// @param report_ The report to read a block number from.\n    /// @param tier_ The Tier to read the block number for.\n    /// @return The block number this has been held since.\n    function tierBlock(uint256 report_, ITier.Tier tier_)\n        internal\n        pure\n        returns (uint256)\n    {\n        // ZERO is a special case. Everyone has always been at least ZERO,\n        // since block 0.\n        if (tier_ == ITier.Tier.ZERO) { return 0; }\n\n        uint256 offset_ = (uint256(tier_) - 1) * 32;\n        return uint256(uint32(\n            uint256(\n                report_ >> offset_\n            )\n        ));\n    }\n\n    /// Resets all the tiers above the reference tier to 0xFFFFFFFF.\n    ///\n    /// @param report_ Report to truncate with high bit 1s.\n    /// @param tier_ Tier to truncate above (exclusive).\n    /// @return Truncated report.\n    function truncateTiersAbove(uint256 report_, ITier.Tier tier_)\n        internal\n        pure\n        returns (uint256)\n    {\n        uint256 offset_ = uint256(tier_) * 32;\n        uint256 mask_ = (UNINITIALIZED >> offset_) << offset_;\n        return report_ | mask_;\n    }\n\n    /// Updates a report with a block number for every status integer in a\n    /// range.\n    ///\n    /// Does nothing if the end status is equal or less than the start status.\n    /// @param report_ The report to update.\n    /// @param startTier_ The `Tier` at the start of the range (exclusive).\n    /// @param endTier_ The `Tier` at the end of the range (inclusive).\n    /// @param blockNumber_ The block number to set for every status\n    /// in the range.\n    /// @return The updated report.\n    function updateBlocksForTierRange(\n        uint256 report_,\n        ITier.Tier startTier_,\n        ITier.Tier endTier_,\n        uint256 blockNumber_\n    )\n        internal pure returns (uint256)\n    {\n        uint256 offset_;\n        for (uint256 i_ = uint256(startTier_); i_ < uint256(endTier_); i_++) {\n            offset_ = i_ * 32;\n            report_ =\n                (report_ & ~uint256(uint256(uint32(UNINITIALIZED)) << offset_))\n                | uint256(blockNumber_ << offset_);\n        }\n        return report_;\n    }\n\n    /// Updates a report to a new status.\n    ///\n    /// Internally dispatches to `truncateTiersAbove` and\n    /// `updateBlocksForTierRange`.\n    /// The dispatch is based on whether the new tier is above or below the\n    /// current tier.\n    /// The `startTier_` MUST match the result of `tierAtBlockFromReport`.\n    /// It is expected the caller will know the current tier when\n    /// calling this function and need to do other things in the calling scope\n    /// with it.\n    ///\n    /// @param report_ The report to update.\n    /// @param startTier_ The tier to start updating relative to. Data above\n    /// this tier WILL BE LOST so probably should be the current tier.\n    /// @param endTier_ The new highest tier held, at the given block number.\n    /// @param blockNumber_ The block number to update the highest tier to, and\n    /// intermediate tiers from `startTier_`.\n    /// @return The updated report.\n    function updateReportWithTierAtBlock(\n        uint256 report_,\n        ITier.Tier startTier_,\n        ITier.Tier endTier_,\n        uint256 blockNumber_\n    )\n        internal pure returns (uint256)\n    {\n        return endTier_ < startTier_\n            ? truncateTiersAbove(report_, endTier_)\n            : updateBlocksForTierRange(\n                report_,\n                startTier_,\n                endTier_,\n                blockNumber_\n            );\n    }\n\n}"
    },
    "contracts/trust/TrustFactory.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.6.12;\n\npragma experimental ABIEncoderV2;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\nimport { ITier } from \"../tier/ITier.sol\";\n\nimport { Factory } from \"../factory/Factory.sol\";\nimport { Trust, TrustConfig } from \"../trust/Trust.sol\";\nimport {\n    RedeemableERC20Factory\n} from \"../redeemableERC20/RedeemableERC20Factory.sol\";\nimport {\n    RedeemableERC20, RedeemableERC20Config\n} from \"../redeemableERC20/RedeemableERC20.sol\";\nimport {\n    RedeemableERC20PoolFactory\n} from \"../pool/RedeemableERC20PoolFactory.sol\";\nimport {\n    RedeemableERC20Pool,\n    RedeemableERC20PoolConfig\n} from \"../pool/RedeemableERC20Pool.sol\";\nimport { SeedERC20Factory } from \"../seed/SeedERC20Factory.sol\";\nimport { SeedERC20Config } from \"../seed/SeedERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport {\n    TrustRedeemableERC20Config,\n    TrustRedeemableERC20PoolConfig\n} from \"./Trust.sol\";\n\n/// Everything required to construct a `TrustFactory`.\nstruct TrustFactoryConfig {\n    // The RedeemableERC20Factory on the current network.\n    // This is an address published by Beehive Trust or deployed locally\n    // during testing.\n    RedeemableERC20Factory redeemableERC20Factory;\n    // The RedeemableERC20PoolFactory on the current network.\n    // This is an address published by Beehive Trust or deployed locally\n    // during testing.\n    RedeemableERC20PoolFactory redeemableERC20PoolFactory;\n    // The SeedERC20Factory on the current network.\n    // This is an address published by Beehive Trust or deployed locally\n    // during testing.\n    SeedERC20Factory seedERC20Factory;\n}\n\nstruct TrustFactoryTrustConfig {\n    // Address of the creator who will receive reserve assets on successful\n    // distribution.\n    address creator;\n    // Minimum amount to raise for the creator from the distribution period.\n    // A successful distribution raises at least this AND also the seed fee and\n    // `redeemInit`;\n    // On success the creator receives these funds.\n    // On failure the creator receives `0`.\n    uint256 minimumCreatorRaise;\n    // Either an EOA (externally owned address) or `address(0)`.\n    // If an EOA the seeder account must transfer seed funds to the newly\n    // constructed `Trust` before distribution can start.\n    // If `address(0)` a new `SeedERC20` contract is built in the `Trust`\n    // constructor.\n    address seeder;\n    // The reserve amount that seeders receive in addition to what they\n    // contribute IFF the raise is successful.\n    // An absolute value, so percentages etc. must be calculated off-chain and\n    // passed in to the constructor.\n    uint256 seederFee;\n    // Total seed units to be mint and sold.\n    // 100% of all seed units must be sold for seeding to complete.\n    // Recommended to keep seed units to a small value (single-triple digits).\n    // The ability for users to buy/sell or not buy/sell dust seed quantities\n    // is likely NOT desired.\n    uint16 seederUnits;\n    // Cooldown duration in blocks for seed/unseed cycles.\n    // Seeding requires locking funds for at least the cooldown period.\n    // Ideally `unseed` is never called and `seed` leaves funds in the contract\n    // until all seed tokens are sold out.\n    // A failed raise cannot make funds unrecoverable, so `unseed` does exist,\n    // but it should be called rarely.\n    uint16 seederCooldownDuration;\n    // The amount of reserve to back the redemption initially after trading\n    // finishes. Anyone can send more of the reserve to the redemption token at\n    // any time to increase redemption value. Successful the redeemInit is sent\n    // to token holders, otherwise the failed raise is refunded instead.\n    uint256 redeemInit;\n}\n\nstruct TrustFactoryTrustRedeemableERC20Config {\n    // Name forwarded to ERC20 constructor.\n    string name;\n    // Symbol forwarded to ERC20 constructor.\n    string symbol;\n    // Tier contract to compare statuses against on transfer.\n    ITier tier;\n    // Minimum status required for transfers in `Phase.ZERO`. Can be `0`.\n    ITier.Tier minimumStatus;\n    // Number of redeemable tokens to mint.\n    uint256 totalSupply;\n}\n\nstruct TrustFactoryTrustRedeemableERC20PoolConfig {\n    // The reserve erc20 token.\n    // The reserve token anchors our newly minted redeemable tokens to an\n    // existant value system.\n    // The weights and balances of the reserve token and the minted token\n    // define a dynamic spot price in the AMM.\n    IERC20 reserve;\n    // Amount of reserve token to initialize the pool.\n    // The starting/final weights are calculated against this.\n    uint256 reserveInit;\n    // Initial marketcap of the token according to the balancer pool\n    // denominated in reserve token.\n    // Th spot price of the token is ( market cap / token supply ) where market\n    // cap is defined in terms of the reserve.\n    // The spot price of a balancer pool token is a function of both the\n    // amounts of each token and their weights.\n    // This bonding curve is described in the balancer whitepaper.\n    // We define a valuation of newly minted tokens in terms of the deposited\n    // reserve. The reserve weight is set to the minimum allowable value to\n    // achieve maximum capital efficiency for the fund raising.\n    uint256 initialValuation;\n    // Final valuation is treated the same as initial valuation.\n    // The final valuation will ONLY be achieved if NO TRADING OCCURS.\n    // Any trading activity that net deposits reserve funds into the pool will\n    // increase the spot price permanently.\n    uint256 finalValuation;\n    // Minimum duration IN BLOCKS of the trading on Balancer.\n    // The trading does not stop until the `anonEndDistribution` function is\n    // called.\n    uint256 minimumTradingDuration;\n}\n\n/// @title TrustFactory\n/// @notice The `TrustFactory` contract is the only contract that the\n/// deployer uses to deploy all contracts for a single project\n/// fundraising event. It takes references to\n/// `RedeemableERC20Factory`, `RedeemableERC20PoolFactory` and\n/// `SeedERC20Factory` contracts, and builds a new `Trust` contract.\n/// @dev Factory for creating and registering new Trust contracts.\ncontract TrustFactory is Factory {\n    using SafeMath for uint256;\n    using SafeERC20 for RedeemableERC20;\n\n    RedeemableERC20Factory public immutable redeemableERC20Factory;\n    RedeemableERC20PoolFactory public immutable redeemableERC20PoolFactory;\n    SeedERC20Factory public immutable seedERC20Factory;\n\n    /// @param config_ All configuration for the `TrustFactory`.\n    constructor(TrustFactoryConfig memory config_) public {\n        redeemableERC20Factory = config_.redeemableERC20Factory;\n        redeemableERC20PoolFactory = config_.redeemableERC20PoolFactory;\n        seedERC20Factory = config_.seedERC20Factory;\n    }\n\n    /// Allows calling `createChild` with TrustConfig,\n    /// TrustRedeemableERC20Config and\n    /// TrustRedeemableERC20PoolConfig parameters.\n    /// Can use original Factory `createChild` function signature if function\n    /// parameters are already encoded.\n    ///\n    /// @param trustFactoryTrustConfig_ Trust constructor configuration.\n    /// @param trustFactoryTrustRedeemableERC20Config_ RedeemableERC20\n    /// constructor configuration.\n    /// @param trustFactoryTrustRedeemableERC20PoolConfig_ RedeemableERC20Pool\n    /// constructor configuration.\n    /// @return New Trust child contract address.\n    function createChild(\n        TrustFactoryTrustConfig\n        calldata\n        trustFactoryTrustConfig_,\n        TrustFactoryTrustRedeemableERC20Config\n        calldata\n        trustFactoryTrustRedeemableERC20Config_,\n        TrustFactoryTrustRedeemableERC20PoolConfig\n        calldata\n        trustFactoryTrustRedeemableERC20PoolConfig_\n    ) external returns(address) {\n        return this.createChild(abi.encode(\n            trustFactoryTrustConfig_,\n            trustFactoryTrustRedeemableERC20Config_,\n            trustFactoryTrustRedeemableERC20PoolConfig_\n        ));\n    }\n\n    /// @inheritdoc Factory\n    function _createChild(\n        bytes calldata data_\n    ) internal virtual override returns(address) {\n        (\n            TrustFactoryTrustConfig\n            memory\n            trustFactoryTrustConfig_,\n            TrustFactoryTrustRedeemableERC20Config\n            memory\n            trustFactoryTrustRedeemableERC20Config_,\n            TrustFactoryTrustRedeemableERC20PoolConfig\n            memory\n            trustFactoryTrustRedeemableERC20PoolConfig_\n        ) = abi.decode(\n            data_,\n            (\n                TrustFactoryTrustConfig,\n                TrustFactoryTrustRedeemableERC20Config,\n                TrustFactoryTrustRedeemableERC20PoolConfig\n            )\n        );\n\n        address trust_ = address(new Trust(\n            TrustConfig(\n                trustFactoryTrustConfig_.creator,\n                trustFactoryTrustConfig_.minimumCreatorRaise,\n                seedERC20Factory,\n                trustFactoryTrustConfig_.seeder,\n                trustFactoryTrustConfig_.seederFee,\n                trustFactoryTrustConfig_.seederUnits,\n                trustFactoryTrustConfig_.seederCooldownDuration,\n                trustFactoryTrustConfig_.redeemInit\n            ),\n            TrustRedeemableERC20Config(\n                redeemableERC20Factory,\n                trustFactoryTrustRedeemableERC20Config_.name,\n                trustFactoryTrustRedeemableERC20Config_.symbol,\n                trustFactoryTrustRedeemableERC20Config_.tier,\n                trustFactoryTrustRedeemableERC20Config_.minimumStatus,\n                trustFactoryTrustRedeemableERC20Config_.totalSupply\n            ),\n            TrustRedeemableERC20PoolConfig(\n                redeemableERC20PoolFactory,\n                trustFactoryTrustRedeemableERC20PoolConfig_.reserve,\n                trustFactoryTrustRedeemableERC20PoolConfig_.reserveInit,\n                trustFactoryTrustRedeemableERC20PoolConfig_.initialValuation,\n                trustFactoryTrustRedeemableERC20PoolConfig_.finalValuation,\n                trustFactoryTrustRedeemableERC20PoolConfig_\n                    .minimumTradingDuration\n            )\n        ));\n\n        return trust_;\n    }\n}"
    },
    "contracts/factory/Factory.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.6.12;\n\npragma experimental ABIEncoderV2;\n\nimport { IFactory } from \"./IFactory.sol\";\nimport {\n    ReentrancyGuard\n} from \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\n\n/// @title Factory\n/// @notice Base contract for deploying and registering child contracts.\nabstract contract Factory is IFactory, ReentrancyGuard {\n    mapping(address => bool) private contracts;\n\n    /// Implements `IFactory`.\n    ///\n    /// `_createChild` hook must be overridden to actually create child\n    /// contract.\n    ///\n    /// Implementers may want to overload this function with a typed equivalent\n    /// to expose domain specific structs etc. to the compiled ABI consumed by\n    /// tooling and other scripts. To minimise gas costs for deployment it is\n    /// expected that the tooling will consume the typed ABI, then encode the\n    /// arguments and pass them to this function directly.\n    ///\n    /// @param data_ ABI encoded data to pass to child contract constructor.\n    // Slither false positive. This is intended to overridden.\n    // https://github.com/crytic/slither/issues/929\n    // slither-disable-next-line dead-code\n    function _createChild(bytes calldata data_)\n        internal\n        virtual\n        returns(address)\n    { } // solhint-disable-line no-empty-blocks\n\n    /// Implements `IFactory`.\n    ///\n    /// Calls the _createChild hook, which inheriting contracts must override.\n    /// Registers child contract address such that `isChild` is `true`.\n    /// Emits `NewContract` event.\n    ///\n    /// @param data_ Encoded data to pass down to child contract constructor.\n    /// @return New child contract address.\n    function createChild(bytes calldata data_)\n        external\n        virtual\n        override\n        nonReentrant\n        returns(address) {\n        // Create child contract using hook.\n        address child_ = _createChild(data_);\n        // Register child contract address to `contracts` mapping.\n        contracts[child_] = true;\n        // Emit `NewContract` event with child contract address.\n        emit IFactory.NewContract(child_);\n        return child_;\n    }\n\n    /// Implements `IFactory`.\n    ///\n    /// Checks if address is registered as a child contract of this factory.\n    ///\n    /// @param maybeChild_ Address of child contract to look up.\n    /// @return Returns `true` if address is a contract created by this\n    /// contract factory, otherwise `false`.\n    function isChild(address maybeChild_)\n        external\n        virtual\n        override\n        returns(bool)\n    {\n        return contracts[maybeChild_];\n    }\n}"
    },
    "contracts/trust/Trust.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.6.12;\n\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\" as ERC20;\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/math/Math.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {\n    ReentrancyGuard\n} from \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\nimport { ITier } from \"../tier/ITier.sol\";\n\nimport { Phase } from \"../phased/Phased.sol\";\nimport {\n    RedeemableERC20,\n    RedeemableERC20Config\n} from \"../redeemableERC20/RedeemableERC20.sol\";\nimport {\n    RedeemableERC20Pool, RedeemableERC20PoolConfig\n} from \"../pool/RedeemableERC20Pool.sol\";\nimport { SeedERC20, SeedERC20Config } from \"../seed/SeedERC20.sol\";\nimport {\n    RedeemableERC20Factory\n} from \"../redeemableERC20/RedeemableERC20Factory.sol\";\nimport {\n    RedeemableERC20PoolFactory,\n    RedeemableERC20PoolFactoryRedeemableERC20PoolConfig\n} from \"../pool/RedeemableERC20PoolFactory.sol\";\nimport {\n    SeedERC20Factory\n} from \"../seed/SeedERC20Factory.sol\";\n\n/// Summary of every contract built or referenced internally by `Trust`.\nstruct TrustContracts {\n    // Reserve erc20 token used to provide value to the created Balancer pool.\n    address reserveERC20;\n    // Redeemable erc20 token that is minted and distributed.\n    address redeemableERC20;\n    // Contract that builds, starts and exits the balancer pool.\n    address redeemableERC20Pool;\n    // Address that provides the initial reserve token seed.\n    address seeder;\n    // Address that defines and controls tier levels for users.\n    address tier;\n    // The Balancer `ConfigurableRightsPool` deployed for this distribution.\n    address crp;\n    // The Balancer pool that holds and trades tokens during the distribution.\n    address pool;\n}\n\n/// High level state of the distribution.\n/// An amalgamation of the phases and states of the internal contracts.\nenum DistributionStatus {\n    // Trust is created but does not have reserve funds required to start the\n    // distribution.\n    Pending,\n    // Trust has enough reserve funds to start the distribution.\n    Seeded,\n    // The balancer pool is funded and trading.\n    Trading,\n    // The last block of the balancer pool gradual weight changes is in the\n    // past.\n    TradingCanEnd,\n    // The balancer pool liquidity has been removed and distribution is\n    // successful.\n    Success,\n    // The balancer pool liquidity has been removed and distribution is a\n    // failure.\n    Fail\n}\n\n/// High level stats of the current state of the distribution.\n/// Includes the `DistributionStatus` and key configuration and metrics.\nstruct DistributionProgress {\n    // `DistributionStatus` as above.\n    DistributionStatus distributionStatus;\n    // First block that the distribution can be traded.\n    // Will be `-1` before trading.\n    uint32 distributionStartBlock;\n    // First block that the distribution can be ended.\n    // Will be `-1` before trading.\n    uint32 distributionEndBlock;\n    // Current reserve balance in the Balancer pool.\n    // Will be `0` before trading.\n    // Will be the exit dust after trading.\n    uint256 poolReserveBalance;\n    // Current token balance in the Balancer pool.\n    // Will be `0` before trading.\n    // Will be `0` after distribution due to burn.\n    uint256 poolTokenBalance;\n    // Initial reserve used to build the Balancer pool.\n    uint256 reserveInit;\n    // Minimum creator reserve value for the distribution to succeed.\n    uint256 minimumCreatorRaise;\n    // Seeder fee paid in reserve if the distribution is a success.\n    uint256 seederFee;\n    // Initial reserve value forwarded to minted redeemable tokens on success.\n    uint256 redeemInit;\n}\n\n/// Configuration specific to constructing the `Trust`.\n/// `Trust` contracts also take inner config for the pool and token.\nstruct TrustConfig {\n    // Address of the creator who will receive reserve assets on successful\n    // distribution.\n    address creator;\n    // Minimum amount to raise for the creator from the distribution period.\n    // A successful distribution raises at least this AND also the seed fee and\n    // `redeemInit`;\n    // On success the creator receives these funds.\n    // On failure the creator receives `0`.\n    uint256 minimumCreatorRaise;\n    // The `SeedERC20Factory` on the current network.\n    SeedERC20Factory seedERC20Factory;\n    // Either an EOA (externally owned address) or `address(0)`.\n    // If an EOA the seeder account must transfer seed funds to the newly\n    // constructed `Trust` before distribution can start.\n    // If `address(0)` a new `SeedERC20` contract is built in the `Trust`\n    // constructor.\n    address seeder;\n    // The reserve amount that seeders receive in addition to what they\n    // contribute IFF the raise is successful.\n    // An absolute value, so percentages etc. must be calculated off-chain and\n    // passed in to the constructor.\n    uint256 seederFee;\n    // Total seed units to be mint and sold.\n    // 100% of all seed units must be sold for seeding to complete.\n    // Recommended to keep seed units to a small value (single-triple digits).\n    // The ability for users to buy/sell or not buy/sell dust seed quantities\n    // is likely NOT desired.\n    uint16 seederUnits;\n    // Cooldown duration in blocks for seed/unseed cycles.\n    // Seeding requires locking funds for at least the cooldown period.\n    // Ideally `unseed` is never called and `seed` leaves funds in the contract\n    // until all seed tokens are sold out.\n    // A failed raise cannot make funds unrecoverable, so `unseed` does exist,\n    // but it should be called rarely.\n    uint16 seederCooldownDuration;\n    // The amount of reserve to back the redemption initially after trading\n    // finishes. Anyone can send more of the reserve to the redemption token at\n    // any time to increase redemption value. Successful the redeemInit is sent\n    // to token holders, otherwise the failed raise is refunded instead.\n    uint256 redeemInit;\n}\n\nstruct TrustRedeemableERC20Config {\n    // The `RedeemableERC20Factory` on the current network.\n    RedeemableERC20Factory redeemableERC20Factory;\n    // Name forwarded to `ERC20` constructor.\n    string name;\n    // Symbol forwarded to `ERC20` constructor.\n    string symbol;\n    // `ITier` contract to compare statuses against on transfer.\n    ITier tier;\n    // Minimum status required for transfers in `Phase.ZERO`. Can be `0`.\n    ITier.Tier minimumStatus;\n    // Number of redeemable tokens to mint.\n    uint256 totalSupply;\n}\n\nstruct TrustRedeemableERC20PoolConfig {\n    // The `RedeemableERC20PoolFactory` on the current network.\n    RedeemableERC20PoolFactory redeemableERC20PoolFactory;\n    // The reserve erc20 token.\n    // The reserve token anchors our newly minted redeemable tokens to an\n    // existant value system.\n    // The weights and balances of the reserve token and the minted token\n    // define a dynamic spot price in the AMM.\n    IERC20 reserve;\n    // Amount of reserve token to initialize the pool.\n    // The starting/final weights are calculated against this.\n    uint256 reserveInit;\n    // Initial marketcap of the token according to the balancer pool\n    // denominated in reserve token.\n    // Th spot price of the token is ( market cap / token supply ) where market\n    // cap is defined in terms of the reserve.\n    // The spot price of a balancer pool token is a function of both the\n    // amounts of each token and their weights.\n    // This bonding curve is described in the balancer whitepaper.\n    // We define a valuation of newly minted tokens in terms of the deposited\n    // reserve. The reserve weight is set to the minimum allowable value to\n    // achieve maximum capital efficiency for the fund raising.\n    uint256 initialValuation;\n    // Final valuation is treated the same as initial valuation.\n    // The final valuation will ONLY be achieved if NO TRADING OCCURS.\n    // Any trading activity that net deposits reserve funds into the pool will\n    // increase the spot price permanently.\n    uint256 finalValuation;\n    // Minimum duration IN BLOCKS of the trading on Balancer.\n    // The trading does not stop until the `anonEndDistribution` function is\n    // called.\n    uint256 minimumTradingDuration;\n}\n\n/// @title Trust\n/// @notice Coordinates the mediation and distribution of tokens\n/// between stakeholders.\n///\n/// The `Trust` contract is responsible for configuring the\n/// `RedeemableERC20` token, `RedeemableERC20Pool` Balancer wrapper\n/// and the `SeedERC20` contract.\n///\n/// Internally the `TrustFactory` calls several admin/owner only\n/// functions on its children and these may impose additional\n/// restrictions such as `Phased` limits.\n///\n/// The `Trust` builds and references `RedeemableERC20`,\n/// `RedeemableERC20Pool` and `SeedERC20` contracts internally and\n/// manages all access-control functionality.\n///\n/// The major functions of the `Trust` contract, apart from building\n/// and configuring the other contracts, is to start and end the\n/// fundraising event, and mediate the distribution of funds to the\n/// correct stakeholders:\n///\n/// - On `Trust` construction, all minted `RedeemableERC20` tokens\n///   are sent to the `RedeemableERC20Pool`\n/// - `anonStartDistribution` can be called by anyone to begin the\n///   Dutch Auction. This will revert if this is called before seeder reserve\n///   funds are available on the `Trust`.\n/// - `anonEndDistribution` can be called by anyone (only when\n///   `RedeemableERC20Pool` is in `Phase.TWO`) to end the Dutch Auction\n///   and distribute funds to the correct stakeholders, depending on\n///   whether or not the auction met the fundraising target.\n///   - On successful raise\n///     - seed funds are returned to `seeder` address along with\n///       additional `seederFee` if configured\n///     - `redeemInit` is sent to the `redeemableERC20` address, to back\n///       redemptions\n///     - the `creator` gets the remaining balance, which should\n///       equal or exceed `minimumCreatorRaise`\n///   - On failed raise\n///     - seed funds are returned to `seeder` address\n///     - the remaining balance is sent to the `redeemableERC20` address, to\n///       back redemptions\n///     - the `creator` gets nothing\n/// @dev Mediates stakeholders and creates internal Balancer pools and tokens\n/// for a distribution.\n///\n/// The goals of a distribution:\n/// - Mint and distribute a `RedeemableERC20` as fairly as possible,\n///   prioritising true fans of a creator.\n/// - Raise a minimum reserve so that a creator can deliver value to fans.\n/// - Provide a safe space through membership style filters to enhance\n///   exclusivity for fans.\n/// - Ensure that anyone who seeds the raise (not fans) by risking and\n///   providing capital is compensated.\n///\n/// Stakeholders:\n/// - Creator: Have a project of interest to their fans\n/// - Fans: Will purchase project-specific tokens to receive future rewards\n///   from the creator\n/// - Seeder(s): Provide initial reserve assets to seed a Balancer trading pool\n/// - Deployer: Configures and deploys the `Trust` contract\n///\n/// The creator is nominated to receive reserve assets on a successful\n/// distribution. The creator must complete the project and fans receive\n/// rewards. There is no on-chain mechanism to hold the creator accountable to\n/// the project completion. Requires a high degree of trust between creator and\n/// their fans.\n///\n/// Fans are willing to trust and provide funds to a creator to complete a\n/// project. Fans likely expect some kind of reward or \"perks\" from the\n/// creator, such as NFTs, exclusive events, etc.\n/// The distributed tokens are untransferable after trading ends and merely act\n/// as records for who should receive rewards.\n///\n/// Seeders add the initial reserve asset to the Balancer pool to start the\n/// automated market maker (AMM).\n/// Ideally this would not be needed at all.\n/// Future versions of `Trust` may include a bespoke distribution mechanism\n/// rather than Balancer contracts. Currently it is required by Balancer so the\n/// seeder provides some reserve and receives a fee on successful distribution.\n/// If the distribution fails the seeder is returned their initial reserve\n/// assets. The seeder is expected to promote and mentor the creator in\n/// non-financial ways.\n///\n/// The deployer has no specific priviledge or admin access once the `Trust` is\n/// deployed. They provide the configuration, including nominating\n/// creator/seeder, and pay gas but that is all.\n/// The deployer defines the conditions under which the distribution is\n/// successful. The seeder/creator could also act as the deployer.\n///\n/// Importantly the `Trust` contract is the owner/admin of the contracts it\n/// creates. The `Trust` never transfers ownership so it directly controls all\n/// internal workflows. No stakeholder, even the deployer or creator, can act\n/// as owner of the internals.\ncontract Trust is ReentrancyGuard {\n\n    using SafeMath for uint256;\n    using Math for uint256;\n\n    using SafeERC20 for IERC20;\n    using SafeERC20 for RedeemableERC20;\n\n    /// Creator from the initial config.\n    address public immutable creator;\n    /// minimum creator raise from the initial config.\n    uint256 public immutable minimumCreatorRaise;\n    /// Seeder from the initial config.\n    address public immutable seeder;\n    /// Seeder fee from the initial config.\n    uint256 public immutable seederFee;\n    /// Seeder units from the initial config.\n    uint16 public immutable seederUnits;\n    /// Seeder cooldown duration from the initial config.\n    uint16 public immutable seederCooldownDuration;\n    /// Redeem init from the initial config.\n    uint256 public immutable redeemInit;\n    /// SeedERC20Factory from the initial config.\n    SeedERC20Factory public immutable seedERC20Factory;\n    /// Balance of the reserve asset in the Balance pool at the moment\n    /// `anonEndDistribution` is called. This must be greater than or equal to\n    /// `successBalance` for the distribution to succeed.\n    /// Will be uninitialized until `anonEndDistribution` is called.\n    /// Note the finalBalance includes the dust that is permanently locked in\n    /// the Balancer pool after the distribution.\n    /// The actual distributed amount will lose roughly 10 ** -7 times this as\n    /// locked dust.\n    /// The exact dust can be retrieved by inspecting the reserve balance of\n    /// the Balancer pool after the distribution.\n    uint256 public finalBalance;\n    /// Pool reserveInit + seederFee + redeemInit + minimumCreatorRaise.\n    /// Could be calculated as a view function but that would require external\n    /// calls to the pool contract.\n    uint256 public immutable successBalance;\n\n    /// The redeemable token minted in the constructor.\n    RedeemableERC20 public immutable token;\n    /// The `RedeemableERC20Pool` pool created for trading.\n    RedeemableERC20Pool public immutable pool;\n\n    /// Sanity checks configuration.\n    /// Creates the `RedeemableERC20` contract and mints the redeemable ERC20\n    /// token.\n    /// Creates the `RedeemableERC20Pool` contract.\n    /// (optional) Creates the `SeedERC20` contract. Pass a non-zero address to\n    /// bypass this.\n    /// Adds the Balancer pool contracts to the token sender/receiver lists as\n    /// needed.\n    /// Adds the Balancer pool reserve asset as the first redeemable on the\n    /// `RedeemableERC20` contract.\n    ///\n    /// Note on slither:\n    /// Slither detects a benign reentrancy in this constructor.\n    /// However reentrancy is not possible in a contract constructor.\n    /// Further discussion with the slither team:\n    /// https://github.com/crytic/slither/issues/887\n    ///\n    /// @param config_ Config for the Trust.\n    // Slither false positive. Constructors cannot be reentrant.\n    // https://github.com/crytic/slither/issues/887\n    // slither-disable-next-line reentrancy-benign\n    constructor (\n        TrustConfig memory config_,\n        TrustRedeemableERC20Config memory trustRedeemableERC20Config_,\n        TrustRedeemableERC20PoolConfig memory trustRedeemableERC20PoolConfig_\n    ) public {\n        require(config_.creator != address(0), \"CREATOR_0\");\n        // There are additional minimum reserve init and token supply\n        // restrictions enforced by `RedeemableERC20` and\n        // `RedeemableERC20Pool`. This ensures that the weightings and\n        // valuations will be in a sensible range according to the internal\n        // assumptions made by Balancer etc.\n        require(\n            trustRedeemableERC20Config_.totalSupply\n            >= trustRedeemableERC20PoolConfig_.reserveInit,\n            \"MIN_TOKEN_SUPPLY\"\n        );\n\n        uint256 successBalance_ = trustRedeemableERC20PoolConfig_.reserveInit\n            .add(config_.seederFee)\n            .add(config_.redeemInit)\n            .add(config_.minimumCreatorRaise);\n\n        creator = config_.creator;\n        seederFee = config_.seederFee;\n        seederUnits = config_.seederUnits;\n        seederCooldownDuration = config_.seederCooldownDuration;\n        redeemInit = config_.redeemInit;\n        minimumCreatorRaise = config_.minimumCreatorRaise;\n        seedERC20Factory = config_.seedERC20Factory;\n        successBalance = successBalance_;\n\n        RedeemableERC20 redeemableERC20_ = RedeemableERC20(\n            trustRedeemableERC20Config_.redeemableERC20Factory\n                .createChild(abi.encode(\n                    RedeemableERC20Config(\n                        address(this),\n                        trustRedeemableERC20Config_.name,\n                        trustRedeemableERC20Config_.symbol,\n                        trustRedeemableERC20Config_.tier,\n                        trustRedeemableERC20Config_.minimumStatus,\n                        trustRedeemableERC20Config_.totalSupply\n        ))));\n\n        RedeemableERC20Pool redeemableERC20Pool_ = RedeemableERC20Pool(\n            trustRedeemableERC20PoolConfig_.redeemableERC20PoolFactory\n                .createChild(abi.encode(\n                    RedeemableERC20PoolFactoryRedeemableERC20PoolConfig(\n                        trustRedeemableERC20PoolConfig_.reserve,\n                        redeemableERC20_,\n                        trustRedeemableERC20PoolConfig_.reserveInit,\n                        trustRedeemableERC20PoolConfig_.initialValuation,\n                        trustRedeemableERC20PoolConfig_.finalValuation,\n                        trustRedeemableERC20PoolConfig_.minimumTradingDuration\n        ))));\n\n        token = redeemableERC20_;\n        pool = redeemableERC20Pool_;\n\n        require(\n            redeemableERC20Pool_.finalValuation() >= successBalance_,\n            \"MIN_FINAL_VALUATION\"\n        );\n\n        if (config_.seeder == address(0)) {\n            require(\n                trustRedeemableERC20PoolConfig_\n                    .reserveInit\n                    .mod(\n                        config_.seederUnits) == 0,\n                        \"SEED_PRICE_MULTIPLIER\"\n                    );\n            config_.seeder = address(config_.seedERC20Factory\n                .createChild(abi.encode(SeedERC20Config(\n                    trustRedeemableERC20PoolConfig_.reserve,\n                    address(redeemableERC20Pool_),\n                    // seed price.\n                    redeemableERC20Pool_\n                        .reserveInit()\n                        .div(config_.seederUnits),\n                    config_.seederUnits,\n                    config_.seederCooldownDuration,\n                    \"\",\n                    \"\"\n                )))\n            );\n        }\n        seeder = config_.seeder;\n\n        // Need to grant transfers for a few balancer addresses to facilitate\n        // setup and exits.\n        redeemableERC20_.grantRole(\n            redeemableERC20_.RECEIVER(),\n            redeemableERC20Pool_.crp().bFactory()\n        );\n        redeemableERC20_.grantRole(\n            redeemableERC20_.RECEIVER(),\n            address(redeemableERC20Pool_.crp())\n        );\n        redeemableERC20_.grantRole(\n            redeemableERC20_.RECEIVER(),\n            address(redeemableERC20Pool_)\n        );\n        redeemableERC20_.grantRole(\n            redeemableERC20_.SENDER(),\n            address(redeemableERC20Pool_.crp())\n        );\n\n        // Need to grant creator ability to add redeemables.\n        redeemableERC20_.grantRole(\n            redeemableERC20_.REDEEMABLE_ADDER(),\n            config_.creator\n        );\n        redeemableERC20_.grantRole(\n            redeemableERC20_.REDEEMABLE_ADDER(),\n            address(this)\n        );\n\n        // The trust needs the ability to burn the distributor.\n        redeemableERC20_.grantRole(\n            redeemableERC20_.DISTRIBUTOR_BURNER(),\n            address(this)\n        );\n\n        // The pool reserve must always be one of the redeemable assets.\n        redeemableERC20_.addRedeemable(\n            trustRedeemableERC20PoolConfig_.reserve\n        );\n\n        // There is no longer any reason for the redeemableERC20 to have an\n        // admin.\n        redeemableERC20_.renounceRole(\n            redeemableERC20_.DEFAULT_ADMIN_ROLE(),\n            address(this)\n        );\n        redeemableERC20_.renounceRole(\n            redeemableERC20_.REDEEMABLE_ADDER(),\n            address(this)\n        );\n\n        // Send all tokens to the pool immediately.\n        // When the seed funds are raised `anonStartDistribution` on the\n        // `Trust` will build a pool from these.\n        redeemableERC20_.safeTransfer(\n            address(redeemableERC20Pool_),\n            trustRedeemableERC20Config_.totalSupply\n        );\n    }\n\n    /// Accessor for the `TrustContracts` of this `Trust`.\n    function getContracts() external view returns(TrustContracts memory) {\n        return TrustContracts(\n            address(pool.reserve()),\n            address(token),\n            address(pool),\n            address(seeder),\n            address(token.tierContract()),\n            address(pool.crp()),\n            address(pool.crp().bPool())\n        );\n    }\n\n    /// Accessor for the `TrustConfig` of this `Trust`.\n    function getTrustConfig() external view returns(TrustConfig memory) {\n        return TrustConfig(\n            address(creator),\n            minimumCreatorRaise,\n            seedERC20Factory,\n            address(seeder),\n            seederFee,\n            seederUnits,\n            seederCooldownDuration,\n            redeemInit\n        );\n    }\n\n    /// Accessor for the `DistributionProgress` of this `Trust`.\n    function getDistributionProgress()\n        external\n        view\n        returns(DistributionProgress memory)\n    {\n        address balancerPool_ = address(pool.crp().bPool());\n        uint256 poolReserveBalance_;\n        uint256 poolTokenBalance_;\n        if (balancerPool_ != address(0)) {\n            poolReserveBalance_ = pool.reserve().balanceOf(balancerPool_);\n            poolTokenBalance_ = token.balanceOf(balancerPool_);\n        }\n        else {\n            poolReserveBalance_ = 0;\n            poolTokenBalance_ = 0;\n        }\n\n        return DistributionProgress(\n            getDistributionStatus(),\n            pool.phaseBlocks(0),\n            pool.phaseBlocks(1),\n            poolReserveBalance_,\n            poolTokenBalance_,\n            pool.reserveInit(),\n            minimumCreatorRaise,\n            seederFee,\n            redeemInit\n        );\n    }\n\n    /// Accessor for the `DistributionStatus` of this `Trust`.\n    function getDistributionStatus() public view returns (DistributionStatus) {\n        Phase poolPhase_ = pool.currentPhase();\n        if (poolPhase_ == Phase.ZERO) {\n            if (\n                pool.reserve().balanceOf(address(pool)) >= pool.reserveInit()\n            ) {\n                return DistributionStatus.Seeded;\n            } else {\n                return DistributionStatus.Pending;\n            }\n        }\n        else if (poolPhase_ == Phase.ONE) {\n            return DistributionStatus.Trading;\n        }\n        else if (poolPhase_ == Phase.TWO) {\n            return DistributionStatus.TradingCanEnd;\n        }\n        else if (poolPhase_ == Phase.THREE) {\n            if (finalBalance >= successBalance) {\n                return DistributionStatus.Success;\n            }\n            else {\n                return DistributionStatus.Fail;\n            }\n        }\n    }\n\n    /// Anyone can end the distribution.\n    /// The requirement is that the `minimumTradingDuration` has elapsed.\n    /// If the `successBalance` is reached then the creator receives the raise\n    /// and seeder earns a fee.\n    /// Else the initial reserve is refunded to the seeder and sale proceeds\n    /// rolled forward to token holders (not the creator).\n    function anonEndDistribution() external nonReentrant {\n        finalBalance = pool.reserve().balanceOf(address(pool.crp().bPool()));\n\n        pool.ownerEndDutchAuction();\n        // Burning the distributor moves the token to its `Phase.ONE` and\n        // unlocks redemptions.\n        // The distributor is the `bPool` itself.\n        // Requires that the `Trust` has been granted `ONLY_DISTRIBUTOR_BURNER`\n        // role on the `redeemableERC20`.\n        token.burnDistributor(\n            address(pool.crp().bPool())\n        );\n\n        // Balancer traps a tiny amount of reserve in the pool when it exits.\n        uint256 poolDust_ = pool.reserve()\n            .balanceOf(address(pool.crp().bPool()));\n        // The dust is included in the final balance for UX reasons.\n        // We don't want to fail the raise due to dust, even if technically it\n        // was a failure.\n        // To ensure a good UX for creators and token holders we subtract the\n        // dust from the seeder.\n        uint256 availableBalance_ = pool.reserve().balanceOf(address(this));\n\n        // Base payments for each fundraiser.\n        uint256 seederPay_ = pool.reserveInit().sub(poolDust_);\n        uint256 creatorPay_ = 0;\n\n        // Set aside the redemption and seed fee if we reached the minimum.\n        if (finalBalance >= successBalance) {\n            // The seeder gets an additional fee on success.\n            seederPay_ = seederPay_.add(seederFee);\n\n            // The creators get new funds raised minus redeem and seed fees.\n            // Can subtract without underflow due to the inequality check for\n            // this code block.\n            // Proof (assuming all positive integers):\n            // final balance >= success balance\n            // AND seed pay = seed init + seed fee\n            // AND success = seed init + seed fee + token pay + min raise\n            // SO success = seed pay + token pay + min raise\n            // SO success >= seed pay + token pay\n            // SO success - (seed pay + token pay) >= 0\n            // SO final balance - (seed pay + token pay) >= 0\n            //\n            // Implied is the remainder of finalBalance_ as redeemInit\n            // This will be transferred to the token holders below.\n            creatorPay_ = availableBalance_.sub(seederPay_.add(redeemInit));\n        }\n\n        if (creatorPay_ > 0) {\n            pool.reserve().safeTransfer(\n                creator,\n                creatorPay_\n            );\n        }\n\n        pool.reserve().safeTransfer(\n            seeder,\n            seederPay_\n        );\n\n        // Send everything left to the token holders.\n        // Implicitly the remainder of the finalBalance_ is:\n        // - the redeem init if successful\n        // - whatever users deposited in the AMM if unsuccessful\n        uint256 remainder_ = pool.reserve().balanceOf(address(this));\n        if (remainder_ > 0) {\n            pool.reserve().safeTransfer(\n                address(token),\n                remainder_\n            );\n        }\n    }\n}"
    },
    "contracts/redeemableERC20/RedeemableERC20Factory.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.6.12;\n\npragma experimental ABIEncoderV2;\n\nimport { Factory } from \"../factory/Factory.sol\";\nimport { RedeemableERC20, RedeemableERC20Config } from \"./RedeemableERC20.sol\";\nimport { ITier } from \"../tier/ITier.sol\";\n\n/// @title RedeemableERC20Factory\n/// @notice Factory for deploying and registering `RedeemableERC20` contracts.\ncontract RedeemableERC20Factory is Factory {\n\n    /// @inheritdoc Factory\n    function _createChild(\n        bytes calldata data_\n    ) internal virtual override returns(address) {\n        (RedeemableERC20Config memory config_) = abi.decode(\n            data_,\n            (RedeemableERC20Config)\n        );\n        RedeemableERC20 redeemableERC20_ = new RedeemableERC20(config_);\n        return address(redeemableERC20_);\n    }\n\n    /// Allows calling `createChild` with `RedeemableERC20Config` struct.\n    /// Use original `Factory` `createChild` function signature if function\n    /// parameters are already encoded.\n    ///\n    /// @param config_ `RedeemableERC20` constructor configuration.\n    /// @return New `RedeemableERC20` child contract address.\n    function createChild(RedeemableERC20Config calldata config_)\n        external\n        returns(address)\n    {\n        return this.createChild(abi.encode(config_));\n    }\n}"
    },
    "contracts/redeemableERC20/RedeemableERC20.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.6.12;\n\npragma experimental ABIEncoderV2;\n\nimport { ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport { SafeMath } from \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport {\n    AccessControl\n} from \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport {\n    ReentrancyGuard\n} from \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport {\n    ERC20Burnable\n} from \"@openzeppelin/contracts/token/ERC20/ERC20Burnable.sol\";\n\nimport {\n    TierByConstruction\n} from \"../tier/TierByConstruction.sol\";\nimport { ITier } from \"../tier/ITier.sol\";\n\nimport { Phase, Phased } from \"../phased/Phased.sol\";\n\n/// Everything required by the `RedeemableERC20` constructor.\nstruct RedeemableERC20Config {\n    // Account that will be the admin for the `RedeemableERC20` contract.\n    // Useful for factory contracts etc.\n    address admin;\n    // Name forwarded to ERC20 constructor.\n    string name;\n    // Symbol forwarded to ERC20 constructor.\n    string symbol;\n    // Tier contract to compare statuses against on transfer.\n    ITier tier;\n    // Minimum status required for transfers in `Phase.ZERO`. Can be `0`.\n    ITier.Tier minimumStatus;\n    // Number of redeemable tokens to mint.\n    uint256 totalSupply;\n}\n\n/// @title RedeemableERC20\n/// @notice This is the ERC20 token that is minted and distributed.\n///\n/// During `Phase.ZERO` the token can be traded and so compatible with the\n/// Balancer pool mechanics.\n///\n/// During `Phase.ONE` the token is frozen and no longer able to be traded on\n/// any AMM or transferred directly.\n///\n/// The token can be redeemed during `Phase.ONE` which burns the token in\n/// exchange for pro-rata erc20 tokens held by the `RedeemableERC20` contract\n/// itself.\n///\n/// The token balances can be used indirectly for other claims, promotions and\n/// events as a proof of participation in the original distribution by token\n/// holders.\n///\n/// The token can optionally be restricted by the `Tier` contract to only allow\n/// receipients with a specified membership status.\n///\n/// @dev `RedeemableERC20` is an ERC20 with 2 phases.\n///\n/// `Phase.ZERO` is the distribution phase where the token can be freely\n/// transfered but not redeemed.\n/// `Phase.ONE` is the redemption phase where the token can be redeemed but no\n/// longer transferred.\n///\n/// Redeeming some amount of `RedeemableERC20` burns the token in exchange for\n/// some other tokens held by the contract. For example, if the\n/// `RedeemableERC20` token contract holds 100 000 USDC then a holder of the\n/// redeemable token can burn some of their tokens to receive a % of that USDC.\n/// If they redeemed (burned) an amount equal to 10% of the redeemable token\n/// supply then they would receive 10 000 USDC.\n///\n/// Up to 8 redeemable tokens can be registered on the redeemable contract.\n/// These will be looped over by default in the `redeem` function. If there is\n/// an error during redemption or more than 8 tokens are to be redeemed, there\n/// is a `redeemSpecific` function that allows the caller to specify exactly\n/// which of the redeemable tokens they want to receive.\n/// Note: The same amount of `RedeemableERC20` is burned, regardless of which\n/// redeemable tokens were specified. Specifying fewer redeemable tokens will\n/// NOT increase the proportion of each that is returned. `redeemSpecific` is\n/// intended as a last resort if the caller cannot resolve issues causing\n/// errors for one or more redeemable tokens during redemption.\n///\n/// `RedeemableERC20` has several owner administrative functions:\n/// - Owner can add senders and receivers that can send/receive tokens even\n///   during `Phase.ONE`\n/// - Owner can add to the list of redeemable tokens\n///   - But NOT remove them\n///   - And everyone can call `redeemSpecific` to override the redeemable list\n/// - Owner can end `Phase.ONE` during `Phase.ZERO` by specifying the address\n///   of a distributor, which will have any undistributed tokens burned.\n///\n/// The intent is that the redeemable token contract is owned by a `Trust`\n/// contract, NOT an externally owned account. The `Trust` contract will add\n/// the minimum possible senders/receivers to facilitate the AMM trading and\n/// redemption.\n///\n/// The `Trust` will also control access to managing redeemable tokens and\n/// specifying the trading AMM pool as the distributor to burn to end\n/// `Phase.ONE`.\n///\n/// The redeem functions MUST be used to redeem and burn RedeemableERC20s\n/// (NOT regular transfers).\n///\n/// The `redeem` and `redeemSpecific` functions will simply revert if called\n/// outside `Phase.ONE`.\n/// A `Redeem` event is emitted on every redemption (per redeemed token) as\n/// `(redeemer, redeemable, redeemAmount)`.\ncontract RedeemableERC20 is\n    AccessControl,\n    Phased,\n    TierByConstruction,\n    ERC20,\n    ReentrancyGuard,\n    ERC20Burnable\n    {\n\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    bytes32 public constant SENDER = keccak256(\"SENDER\");\n    bytes32 public constant RECEIVER = keccak256(\"RECEIVER\");\n    bytes32 public constant DISTRIBUTOR_BURNER =\n        keccak256(\"DISTRIBUTOR_BURNER\");\n    bytes32 public constant REDEEMABLE_ADDER = keccak256(\"REDEEMABLE_ADDER\");\n\n    /// Redeemable token burn for reserve.\n    event Redeem(\n        // Account burning and receiving.\n        address indexed redeemer,\n        // The token being sent to the burner.\n        address indexed redeemable,\n        // The amount of the redeemable and token being redeemed as\n        // `[redeemAmount, tokenAmount]`\n        uint256[2] redeemAmounts\n    );\n\n    /// RedeemableERC20 uses the standard/default 18 ERC20 decimals.\n    /// The minimum supply enforced by the constructor is \"one\" token which is\n    /// `10 ** 18`.\n    /// The minimum supply does not prevent subsequent redemption/burning.\n    uint256 public constant MINIMUM_INITIAL_SUPPLY = 10 ** 18;\n\n    /// The maximum number of redeemables that can be set.\n    /// Attempting to add more redeemables than this will fail with an error.\n    /// This prevents a very large loop in the default redemption behaviour.\n    uint8 public constant MAX_REDEEMABLES = 8;\n\n    /// @dev List of redeemables to loop over in default redemption behaviour.\n    /// see `getRedeemables`.\n    IERC20[] private redeemables;\n\n    /// The minimum status that a user must hold to receive transfers during\n    /// `Phase.ZERO`.\n    /// The tier contract passed to `TierByConstruction` determines if\n    /// the status is held during `_beforeTokenTransfer`.\n    /// Not immutable because it is read during the constructor by the `_mint`\n    /// call.\n    ITier.Tier public minimumTier;\n\n    /// Mint the full ERC20 token supply and configure basic transfer\n    /// restrictions.\n    /// @param config_ Constructor configuration.\n    constructor (\n        RedeemableERC20Config memory config_\n    )\n        public\n        ERC20(config_.name, config_.symbol)\n        TierByConstruction(config_.tier)\n    {\n        require(\n            config_.totalSupply >= MINIMUM_INITIAL_SUPPLY,\n            \"MINIMUM_INITIAL_SUPPLY\"\n        );\n        minimumTier = config_.minimumStatus;\n\n        _setupRole(DEFAULT_ADMIN_ROLE, config_.admin);\n        _setupRole(RECEIVER, config_.admin);\n\n        _mint(config_.admin, config_.totalSupply);\n    }\n\n    /// The admin can burn all tokens of a single address to end `Phase.ZERO`.\n    /// The intent is that during `Phase.ZERO` there is some contract\n    /// responsible for distributing the tokens.\n    /// The admin specifies the distributor to end `Phase.ZERO` and all\n    /// undistributed tokens are burned.\n    /// The distributor is NOT set during the constructor because it likely\n    /// doesn't exist at that point. For example, Balancer needs the paired\n    /// erc20 tokens to exist before the trading pool can be built.\n    /// @param distributorAccount_ The distributor according to the admin.\n    function burnDistributor(address distributorAccount_)\n        external\n        onlyPhase(Phase.ZERO)\n    {\n        require(\n            hasRole(DISTRIBUTOR_BURNER, msg.sender),\n            \"ONLY_DISTRIBUTOR_BURNER\"\n        );\n        scheduleNextPhase(uint32(block.number));\n        _burn(distributorAccount_, balanceOf(distributorAccount_));\n    }\n\n    /// Admin can add up to 8 redeemables to this contract.\n    /// Each redeemable will be sent to token holders when they call redeem\n    /// functions in `Phase.ONE` to burn tokens.\n    /// If the admin adds a non-compliant or malicious IERC20 address then\n    /// token holders can override the list with `redeemSpecific`.\n    /// @param newRedeemable_ The redeemable contract address to add.\n    function addRedeemable(IERC20 newRedeemable_) external {\n        require(\n            hasRole(REDEEMABLE_ADDER, msg.sender),\n            \"ONLY_REDEEMABLE_ADDER\"\n        );\n        // Somewhat arbitrary but we limit the length of redeemables to 8.\n        // 8 is actually a lot. Consider that every `redeem` call must loop a\n        // `balanceOf` and `safeTransfer` per redeemable.\n        require(redeemables.length<MAX_REDEEMABLES, \"MAX_REDEEMABLES\");\n        for (uint256 i_ = 0; i_<redeemables.length;i_++) {\n            require(redeemables[i_] != newRedeemable_, \"DUPLICATE_REDEEMABLE\");\n        }\n        redeemables.push(newRedeemable_);\n    }\n\n    /// Public getter for underlying registered redeemables as a fixed sized\n    /// array.\n    /// The underlying array is dynamic but fixed size return values provide\n    /// clear bounds on gas etc.\n    /// @return Dynamic `redeemables` mapped to a fixed size array.\n    function getRedeemables() external view returns (address[8] memory) {\n        // Slither false positive here due to a bug in slither.\n        // https://github.com/crytic/slither/issues/884\n        // slither-disable-next-line uninitialized-local\n        address[8] memory redeemablesArray_;\n        for(uint256 i_ = 0;i_<redeemables.length;i_++) {\n            redeemablesArray_[i_] = address(redeemables[i_]);\n        }\n        return redeemablesArray_;\n    }\n\n    /// Redeem tokens.\n    /// Tokens can be redeemed but NOT transferred during `Phase.ONE`.\n    ///\n    /// Calculate the redeem value of tokens as:\n    ///\n    /// ```\n    /// ( redeemAmount / redeemableErc20Token.totalSupply() )\n    /// * token.balanceOf(address(this))\n    /// ```\n    ///\n    /// This means that the users get their redeemed pro-rata share of the\n    /// outstanding token supply burned in return for a pro-rata share of the\n    /// current balance of each redeemable token.\n    ///\n    /// I.e. whatever % of redeemable tokens the sender burns is the % of the\n    /// current reserve they receive.\n    ///\n    /// Note: Any tokens held by `address(0)` are burned defensively.\n    ///       This is because transferring directly to `address(0)` will\n    ///       succeed but the `totalSupply` won't reflect it.\n    function redeemSpecific(\n        IERC20[] memory specificRedeemables_,\n        uint256 redeemAmount_\n    )\n        public\n        onlyPhase(Phase.ONE)\n        nonReentrant\n    {\n        // The fraction of the redeemables we release is the fraction of the\n        // outstanding total supply passed in.\n        // Every redeemable is released in the same proportion.\n        uint256 supplyBeforeBurn_ = totalSupply();\n\n        // Redeem __burns__ tokens which reduces the total supply and requires\n        // no approval.\n        // `_burn` reverts internally if needed (e.g. if burn exceeds balance).\n        // This function is `nonReentrant` but we burn before redeeming anyway.\n        _burn(msg.sender, redeemAmount_);\n\n        for(uint256 i_ = 0; i_ < specificRedeemables_.length; i_++) {\n            IERC20 ithRedeemable_ = specificRedeemables_[i_];\n            uint256 tokenAmount_ = ithRedeemable_\n                .balanceOf(address(this))\n                .mul(redeemAmount_)\n                .div(supplyBeforeBurn_);\n            emit Redeem(\n                msg.sender,\n                address(ithRedeemable_),\n                [redeemAmount_, tokenAmount_]\n            );\n            ithRedeemable_.safeTransfer(\n                msg.sender,\n                tokenAmount_\n            );\n        }\n    }\n\n    /// Default redemption behaviour.\n    /// Thin wrapper for `redeemSpecific`.\n    /// `msg.sender` specifies an amount of their own redeemable token to\n    /// redeem.\n    /// Each redeemable token specified by this contract's admin will be sent\n    /// to the sender pro-rata.\n    /// The sender's tokens are burned in the process.\n    /// @param redeemAmount_ The amount of the sender's redeemable erc20 to\n    /// burn.\n    function redeem(uint256 redeemAmount_) external {\n        redeemSpecific(redeemables, redeemAmount_);\n    }\n\n    /// Sanity check to ensure `Phase.ONE` is the final phase.\n    /// @inheritdoc Phased\n    // Slither false positive. This is overriding an Open Zeppelin hook.\n    // https://github.com/crytic/slither/issues/929\n    // slither-disable-next-line dead-code\n    function _beforeScheduleNextPhase(uint32 nextPhaseBlock_)\n        internal\n        override\n        virtual\n    {\n        super._beforeScheduleNextPhase(nextPhaseBlock_);\n        assert(currentPhase() < Phase.TWO);\n    }\n\n    /// Apply phase sensitive transfer restrictions.\n    /// During `Phase.ZERO` only tier requirements apply.\n    /// During `Phase.ONE` all transfers except burns are prevented.\n    /// If a transfer involves either a sender or receiver with the relevant\n    /// `unfreezables` state it will ignore these restrictions.\n    /// @inheritdoc ERC20\n    // Slither false positive. This is overriding an Open Zeppelin hook.\n    // https://github.com/crytic/slither/issues/929\n    // slither-disable-next-line dead-code\n    function _beforeTokenTransfer(\n        address sender_,\n        address receiver_,\n        uint256 amount_\n    )\n        internal\n        override\n        virtual\n    {\n        super._beforeTokenTransfer(sender_, receiver_, amount_);\n\n        // Sending tokens to this contract (e.g. instead of redeeming) is\n        // always an error.\n        require(receiver_ != address(this), \"TOKEN_SEND_SELF\");\n\n        // Some contracts may attempt a preflight (e.g. Balancer) of a 0 amount\n        // transfer.\n        // We don't want to accidentally cause external errors due to zero\n        // value transfers.\n        if (amount_ > 0\n            // The sender and receiver lists bypass all access restrictions.\n            && !(hasRole(SENDER, sender_) || hasRole(RECEIVER, receiver_))) {\n            // During `Phase.ZERO` transfers are only restricted by the\n            // tier of the recipient.\n            if (currentPhase() == Phase.ZERO) {\n                require(\n                    isTier(receiver_, minimumTier),\n                    \"MIN_TIER\"\n                );\n            }\n            // During `Phase.ONE` only token burns are allowed.\n            else if (currentPhase() == Phase.ONE) {\n                require(receiver_ == address(0), \"FROZEN\");\n            }\n            // There are no other phases.\n            else { assert(false); }\n        }\n    }\n}\n"
    },
    "contracts/pool/RedeemableERC20PoolFactory.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.6.12;\n\npragma experimental ABIEncoderV2;\n\nimport { Factory } from \"../factory/Factory.sol\";\nimport {\n    RedeemableERC20Pool,\n    RedeemableERC20PoolConfig\n} from \"./RedeemableERC20Pool.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { RedeemableERC20 } from \"../redeemableERC20/RedeemableERC20.sol\";\n\n/// Everything required to construct a `RedeemableERC20PoolFactory`.\nstruct RedeemableERC20PoolFactoryConfig {\n    // The `CRPFactory` on the current network.\n    // This is an address published by Balancer or deployed locally during\n    // testing.\n    address crpFactory;\n    // The `BFactory` on the current network.\n    // This is an address published by Balancer or deployed locally during\n    // testing.\n    address balancerFactory;\n}\n\n/// Everything else required to construct new `RedeemableERC20Pool` child\n/// contracts.\nstruct RedeemableERC20PoolFactoryRedeemableERC20PoolConfig {\n    // The reserve erc20 token.\n    // The reserve token anchors our newly minted redeemable tokens to an\n    // existant value system.\n    // The weights and balances of the reserve token and the minted token\n    // define a dynamic spot price in the AMM.\n    IERC20 reserve;\n    // The newly minted redeemable token contract.\n    // 100% of the total supply of the token MUST be transferred to the\n    // `RedeemableERC20Pool` for it to function.\n    // This implies a 1:1 relationship between redeemable pools and tokens.\n    // IMPORTANT: It is up to the caller to define a reserve that will remain\n    // functional and outlive the RedeemableERC20.\n    // For example, USDC could freeze the tokens owned by the RedeemableERC20\n    // contract or close their business.\n    RedeemableERC20 token;\n    // Amount of reserve token to initialize the pool.\n    // The starting/final weights are calculated against this.\n    uint256 reserveInit;\n    // Initial marketcap of the token according to the balancer pool\n    // denominated in reserve token.\n    // Th spot price of the token is ( market cap / token supply ) where market\n    // cap is defined in terms of the reserve.\n    // The spot price of a balancer pool token is a function of both the\n    // amounts of each token and their weights.\n    // This bonding curve is described in the balancer whitepaper.\n    // We define a valuation of newly minted tokens in terms of the deposited\n    // reserve. The reserve weight is set to the minimum allowable value to\n    // achieve maximum capital efficiency for the fund raising.\n    uint256 initialValuation;\n    // Final valuation is treated the same as initial valuation.\n    // The final valuation will ONLY be achieved if NO TRADING OCCURS.\n    // Any trading activity that net deposits reserve funds into the pool will\n    // increase the spot price permanently.\n    uint256 finalValuation;\n    // Minimum duration IN BLOCKS of the trading on Balancer.\n    // The trading does not stop until the `anonEndDistribution` function is\n    // called.\n    uint256 minimumTradingDuration;\n}\n\n/// @title RedeemableERC20PoolFactory\n/// @notice Factory for creating and registering new `RedeemableERC20Pool`\n/// contracts.\ncontract RedeemableERC20PoolFactory is Factory {\n    /// ConfigurableRightsPool factory.\n    address public immutable crpFactory;\n    /// Balancer factory.\n    address public immutable balancerFactory;\n\n    /// @param config_ All configuration for the `RedeemableERC20PoolFactory`.\n    constructor(RedeemableERC20PoolFactoryConfig memory config_) public {\n        crpFactory = config_.crpFactory;\n        balancerFactory = config_.balancerFactory;\n    }\n\n    /// @inheritdoc Factory\n    function _createChild(\n        bytes calldata data_\n    ) internal virtual override returns(address) {\n        (\n            RedeemableERC20PoolFactoryRedeemableERC20PoolConfig\n            memory\n            config_\n        ) = abi.decode(\n            data_,\n            (RedeemableERC20PoolFactoryRedeemableERC20PoolConfig)\n        );\n        RedeemableERC20Pool pool_ = new RedeemableERC20Pool(\n            RedeemableERC20PoolConfig(\n                crpFactory,\n                balancerFactory,\n                config_.reserve,\n                config_.token,\n                config_.reserveInit,\n                config_.initialValuation,\n                config_.finalValuation,\n                config_.minimumTradingDuration\n            )\n        );\n        /// Transfer Balancer pool ownership to sender (e.g. `Trust`).\n        pool_.transferOwnership(msg.sender);\n        return address(pool_);\n    }\n\n    /// Allows calling `createChild` with\n    /// `RedeemableERC20PoolFactoryRedeemableERC20PoolConfig` struct.\n    /// Can use original Factory `createChild` function signature if function\n    /// parameters are already encoded.\n    ///\n    /// @param config_ `RedeemableERC20Pool` constructor configuration.\n    /// @return New `RedeemableERC20Pool` child contract address.\n    function createChild(\n        RedeemableERC20PoolFactoryRedeemableERC20PoolConfig\n        calldata\n        config_\n    )\n        external\n        returns(address)\n    {\n        return this.createChild(abi.encode(config_));\n    }\n}"
    },
    "contracts/pool/RedeemableERC20Pool.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.6.12;\n\npragma experimental ABIEncoderV2;\n\nimport { SafeMath } from \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { Math } from \"@openzeppelin/contracts/math/Math.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\nimport { Rights } from \"./IRightsManager.sol\";\nimport { ICRPFactory } from \"./ICRPFactory.sol\";\nimport {\n    PoolParams, IConfigurableRightsPool\n} from \"./IConfigurableRightsPool.sol\";\n\nimport {\n    IBalancerConstants\n} from\n\"./IBalancerConstants.sol\";\n\nimport { Phase, Phased } from \"../phased/Phased.sol\";\nimport { RedeemableERC20 } from \"../redeemableERC20/RedeemableERC20.sol\";\n\n/// Everything required to construct a `RedeemableERC20Pool`.\nstruct RedeemableERC20PoolConfig {\n    // The CRPFactory on the current network.\n    // This is an address published by Balancer or deployed locally during\n    // testing.\n    address crpFactory;\n    // The BFactory on the current network.\n    // This is an address published by Balancer or deployed locally during\n    // testing.\n    address balancerFactory;\n    // The reserve erc20 token.\n    // The reserve token anchors our newly minted redeemable tokens to an\n    // existant value system.\n    // The weights and balances of the reserve token and the minted token\n    // define a dynamic spot price in the AMM.\n    IERC20 reserve;\n    // The newly minted redeemable token contract.\n    // 100% of the total supply of the token MUST be transferred to the\n    // `RedeemableERC20Pool` for it to function.\n    // This implies a 1:1 relationship between redeemable pools and tokens.\n    // IMPORTANT: It is up to the caller to define a reserve that will remain\n    // functional and outlive the RedeemableERC20.\n    // For example, USDC could freeze the tokens owned by the RedeemableERC20\n    // contract or close their business.\n    RedeemableERC20 token;\n    // Amount of reserve token to initialize the pool.\n    // The starting/final weights are calculated against this.\n    uint256 reserveInit;\n    // Initial marketcap of the token according to the balancer pool\n    // denominated in reserve token.\n    // The spot price of the token is ( market cap / token supply ) where\n    // market cap is defined in terms of the reserve.\n    // The spot price of a balancer pool token is a function of both the\n    // amounts of each token and their weights.\n    // This bonding curve is described in the Balancer whitepaper.\n    // We define a valuation of newly minted tokens in terms of the deposited\n    // reserve. The reserve weight is set to the minimum allowable value to\n    // achieve maximum capital efficiency for the fund raising.\n    uint256 initialValuation;\n    // Final valuation is treated the same as initial valuation.\n    // The final valuation will ONLY be achieved if NO TRADING OCCURS.\n    // Any trading activity that net deposits reserve funds into the pool will\n    // increase the spot price permanently.\n    uint256 finalValuation;\n    // Minimum duration IN BLOCKS of the trading on Balancer.\n    // The trading does not stop until the `anonEndDistribution` function is\n    // called on the owning `Trust`.\n    uint256 minimumTradingDuration;\n}\n\n/// @title RedeemableERC20Pool\n/// @notice The Balancer functionality is wrapped by the\n/// `RedeemableERC20Pool` contract.\n///\n/// Balancer pools require significant configuration so this contract helps\n/// decouple the implementation from the `Trust`.\n///\n/// It also ensures the pool tokens created during the initialization of the\n/// Balancer LBP are owned by the `RedeemableERC20Pool` and never touch either\n/// the `Trust` nor an externally owned account (EOA).\n///\n/// `RedeemableERC20Pool` has several phases:\n///\n/// - `Phase.ZERO`: Deployed not trading but can be by owner calling\n/// `ownerStartDutchAuction`\n/// - `Phase.ONE`: Trading open\n/// - `Phase.TWO`: Trading open but can be closed by owner calling\n/// `ownerEndDutchAuction`\n/// - `Phase.THREE`: Trading closed\n///\n/// @dev Deployer and controller for a Balancer ConfigurableRightsPool.\n/// This contract is intended in turn to be owned by a `Trust`.\n///\n/// Responsibilities of `RedeemableERC20Pool`:\n/// - Configure and deploy Balancer contracts with correct weights, rights and\n///   balances\n/// - Allowing the owner to start and end a dutch auction raise modelled as\n///   Balancer's \"gradual weights\" functionality\n/// - Tracking and enforcing 3 phases: unstarted, started, ended\n/// - Burning unsold tokens after the raise and forwarding all raised and\n///   initial reserve back to the owner\n///\n/// Responsibilities of the owner:\n/// - Providing all token and reserve balances\n/// - Calling start and end raise functions\n/// - Handling the reserve proceeds of the raise\ncontract RedeemableERC20Pool is Ownable, Phased {\n    using SafeMath for uint256;\n    using Math for uint256;\n    using SafeERC20 for IERC20;\n    using SafeERC20 for RedeemableERC20;\n\n    /// Balancer requires a minimum balance of `10 ** 6` for all tokens at all\n    /// times.\n    uint256 public constant MIN_BALANCER_POOL_BALANCE = 10 ** 6;\n    /// To ensure that the dust at the end of the raise is dust-like, we\n    /// enforce a minimum starting reserve balance 100x the minimum.\n    uint256 public constant MIN_RESERVE_INIT = 10 ** 8;\n\n    /// RedeemableERC20 token.\n    RedeemableERC20 public immutable token;\n\n    /// Minimum trading duration from the initial config.\n    uint256 public immutable minimumTradingDuration;\n\n    /// Reserve token.\n    IERC20 public immutable reserve;\n    /// Initial reserve balance of the pool.\n    uint256 public immutable reserveInit;\n\n    /// The `ConfigurableRightsPool` built during construction.\n    IConfigurableRightsPool public immutable crp;\n\n    /// The final weight on the last block of the raise.\n    /// Note the spot price is unknown until the end because we don't know\n    /// either of the final token balances.\n    uint256 public immutable finalWeight;\n    uint256 public immutable finalValuation;\n\n    /// @param config_ All configuration for the `RedeemableERC20Pool`.\n    // Slither false positive. Constructors cannot be reentrant.\n    // https://github.com/crytic/slither/issues/887\n    // slither-disable-next-line reentrancy-benign\n    constructor (RedeemableERC20PoolConfig memory config_) public {\n        require(\n            config_.reserveInit >= MIN_RESERVE_INIT,\n            \"RESERVE_INIT_MINIMUM\"\n        );\n        require(\n            config_.initialValuation >= config_.finalValuation,\n            \"MIN_INITIAL_VALUTION\"\n        );\n\n        token = config_.token;\n        reserve = config_.reserve;\n        reserveInit = config_.reserveInit;\n\n        finalWeight = valuationWeight(\n            config_.reserveInit,\n            config_.finalValuation\n        );\n        finalValuation = config_.finalValuation;\n\n        require(config_.minimumTradingDuration > 0, \"0_TRADING_DURATION\");\n        minimumTradingDuration = config_.minimumTradingDuration;\n\n        // Build the CRP.\n        // The addresses in the `RedeemableERC20Pool`, as `[reserve, token]`.\n        address[] memory poolAddresses_ = new address[](2);\n        poolAddresses_[0] = address(config_.reserve);\n        poolAddresses_[1] = address(config_.token);\n\n        uint256[] memory poolAmounts_ = new uint256[](2);\n        poolAmounts_[0] = config_.reserveInit;\n        poolAmounts_[1] = config_.token.totalSupply();\n        require(poolAmounts_[1] > 0, \"TOKEN_INIT_0\");\n\n        uint256[] memory initialWeights_ = new uint256[](2);\n        initialWeights_[0] = IBalancerConstants.MIN_WEIGHT;\n        initialWeights_[1] = valuationWeight(\n            config_.reserveInit,\n            config_.initialValuation\n        );\n\n        address crp_ = ICRPFactory(config_.crpFactory).newCrp(\n            config_.balancerFactory,\n            PoolParams(\n                \"R20P\",\n                \"RedeemableERC20Pool\",\n                poolAddresses_,\n                poolAmounts_,\n                initialWeights_,\n                IBalancerConstants.MIN_FEE\n            ),\n            Rights(\n                // 0. Pause\n                false,\n                // 1. Change fee\n                false,\n                // 2. Change weights\n                // (`true` needed to set gradual weight schedule)\n                true,\n                // 3. Add/remove tokens\n                false,\n                // 4. Whitelist LPs (default behaviour for `true` is that\n                //    nobody can `joinPool`)\n                true,\n                // 5. Change cap\n                false\n            )\n        );\n        crp = IConfigurableRightsPool(crp_);\n\n        // Preapprove all tokens and reserve for the CRP.\n        require(\n            config_.reserve.approve(address(crp_), config_.reserveInit),\n            \"RESERVE_APPROVE\"\n        );\n        require(\n            config_.token.approve(address(crp_),\n            config_.token.totalSupply()),\n            \"TOKEN_APPROVE\"\n        );\n    }\n\n    /// https://balancer.finance/whitepaper/\n    /// Spot = ( Br / Wr ) / ( Bt / Wt )\n    /// => ( Bt / Wt ) = ( Br / Wr ) / Spot\n    /// => Wt = ( Spot x Bt ) / ( Br / Wr )\n    ///\n    /// Valuation = Spot * Token supply\n    /// Valuation / Supply = Spot\n    /// => Wt = ( ( Val / Supply ) x Bt ) / ( Br / Wr )\n    ///\n    /// Bt = Total supply\n    /// => Wt = ( ( Val / Bt ) x Bt ) / ( Br / Wr )\n    /// => Wt = Val / ( Br / Wr )\n    ///\n    /// Wr = Min weight = 1\n    /// => Wt = Val / Br\n    ///\n    /// Br = reserve init (assumes zero trading)\n    /// => Wt = Val / reserve init\n    /// @param valuation_ Valuation as ( market cap * price ) denominated in\n    /// reserve to calculate a weight for.\n    function valuationWeight(uint256 reserveInit_, uint256 valuation_)\n        private\n        pure\n        returns (uint256)\n    {\n        uint256 weight_ = valuation_\n            .mul(IBalancerConstants.BONE)\n            .div(reserveInit_);\n        require(\n            weight_ >= IBalancerConstants.MIN_WEIGHT,\n            \"MIN_WEIGHT_VALUATION\"\n        );\n        // The combined weight of both tokens cannot exceed the maximum even\n        // temporarily during a transaction so we need to subtract one for\n        // headroom.\n        require(\n            IBalancerConstants.MAX_WEIGHT.sub(IBalancerConstants.BONE)\n            >= IBalancerConstants.MIN_WEIGHT.add(weight_),\n            \"MAX_WEIGHT_VALUATION\"\n        );\n        return weight_;\n    }\n\n    /// Allow anyone to start the Balancer style dutch auction.\n    /// The auction won't start unless this contract owns enough of both the\n    /// tokens for the pool, so it is safe for anon to call.\n    /// `Phase.ZERO` indicates the auction can start.\n    /// `Phase.ONE` indicates the auction has started.\n    /// `Phase.TWO` indicates the auction can be ended.\n    /// `Phase.THREE` indicates the auction has ended.\n    /// Creates the pool via. the CRP contract and configures the weight change\n    /// curve.\n    function startDutchAuction() external onlyPhase(Phase.ZERO)\n    {\n        uint256 finalAuctionBlock_ = minimumTradingDuration + block.number;\n        // Move to `Phase.ONE` immediately.\n        scheduleNextPhase(uint32(block.number));\n        // Schedule `Phase.TWO` for `1` block after auctions weights have\n        // stopped changing.\n        scheduleNextPhase(uint32(finalAuctionBlock_ + 1));\n\n        // Define the weight curve.\n        uint256[] memory finalWeights_ = new uint256[](2);\n        finalWeights_[0] = IBalancerConstants.MIN_WEIGHT;\n        finalWeights_[1] = finalWeight;\n\n        // Max pool tokens to minimise dust on exit.\n        // No minimum weight change period.\n        // No time lock (we handle our own locks in the trust).\n        crp.createPool(IBalancerConstants.MAX_POOL_SUPPLY, 0, 0);\n        crp.updateWeightsGradually(\n            finalWeights_,\n            block.number,\n            finalAuctionBlock_\n        );\n    }\n\n    /// Allow the owner to end the Balancer style dutch auction.\n    /// Moves from `Phase.TWO` to `Phase.THREE` to indicate the auction has\n    /// ended.\n    /// `Phase.TWO` is scheduled by `startDutchAuction`.\n    /// Removes all LP tokens from the Balancer pool.\n    /// Burns all unsold redeemable tokens.\n    /// Forwards the reserve balance to the owner.\n    function ownerEndDutchAuction() external onlyOwner onlyPhase(Phase.TWO) {\n        // Move to `Phase.THREE` immediately.\n        // In `Phase.THREE` all `RedeemableERC20Pool` functions are no longer\n        // callable.\n        scheduleNextPhase(uint32(block.number));\n\n        // Balancer enforces a global minimum pool LP token supply as\n        // `MIN_POOL_SUPPLY`.\n        // Balancer also indirectly enforces local minimums on pool token\n        // supply by enforcing minimum erc20 token balances in the pool.\n        // The real minimum pool LP token supply is the largest of:\n        // - The global minimum\n        // - The LP token supply implied by the reserve\n        // - The LP token supply implied by the token\n        uint256 minReservePoolTokens = MIN_BALANCER_POOL_BALANCE\n            .mul(IBalancerConstants.MAX_POOL_SUPPLY)\n            .div(reserve.balanceOf(crp.bPool()));\n        // The minimum redeemable token supply is `10 ** 18` so it is near\n        // impossible to hit this before the reserve or global pool minimums.\n        uint256 minRedeemablePoolTokens = MIN_BALANCER_POOL_BALANCE\n            .mul(IBalancerConstants.MAX_POOL_SUPPLY)\n            .div(token.balanceOf(crp.bPool()));\n        uint256 minPoolSupply_ = IBalancerConstants.MIN_POOL_SUPPLY\n            .max(minReservePoolTokens)\n            .max(minRedeemablePoolTokens);\n\n        // This removes as much as is allowable which leaves behind some dust.\n        // The reserve dust will be trapped.\n        // The redeemable token will be burned when it moves to its own\n        // `Phase.ONE`.\n        crp.exitPool(\n            IERC20(address(crp)).balanceOf(address(this)) - minPoolSupply_,\n            new uint256[](2)\n        );\n\n        // Burn all unsold token inventory.\n        token.burn(token.balanceOf(address(this)));\n\n        // Send reserve back to owner (`Trust`) to be distributed to\n        // stakeholders.\n        reserve.safeTransfer(\n            owner(),\n            reserve.balanceOf(address(this))\n        );\n    }\n\n    /// Enforce `Phase.THREE` as the last phase.\n    /// @inheritdoc Phased\n    function _beforeScheduleNextPhase(uint32 nextPhaseBlock_)\n        internal\n        override\n        virtual\n    {\n        super._beforeScheduleNextPhase(nextPhaseBlock_);\n        assert(currentPhase() < Phase.THREE);\n    }\n}"
    },
    "contracts/seed/SeedERC20Factory.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.6.12;\n\npragma experimental ABIEncoderV2;\n\nimport { Factory } from \"../factory/Factory.sol\";\nimport { SeedERC20, SeedERC20Config } from \"./SeedERC20.sol\";\n\n/// @title SeedERC20Factory\n/// @notice Factory for creating and deploying `SeedERC20` contracts.\ncontract SeedERC20Factory is Factory {\n\n    /// @inheritdoc Factory\n    function _createChild(\n        bytes calldata data_\n    ) internal virtual override returns(address) {\n        (SeedERC20Config memory config_) = abi.decode(\n            data_,\n            (SeedERC20Config)\n        );\n        return address(new SeedERC20(config_));\n    }\n\n    /// Allows calling `createChild` with `SeedERC20Config` struct.\n    /// Use original `Factory` `createChild` function signature if function\n    /// parameters are already encoded.\n    ///\n    /// @param config_ `SeedERC20` constructor configuration.\n    /// @return New `SeedERC20` child contract address.\n    function createChild(SeedERC20Config calldata config_)\n        external\n        returns(address)\n    {\n        return this.createChild(abi.encode(config_));\n    }\n}"
    },
    "contracts/seed/SeedERC20.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.6.12;\n\npragma experimental ABIEncoderV2;\n\nimport { ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport { SafeMath } from \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport { Math } from \"@openzeppelin/contracts/math/Math.sol\";\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport { Phase, Phased } from \"../phased/Phased.sol\";\nimport { Cooldown } from \"../cooldown/Cooldown.sol\";\n\n/// Everything required to construct a `SeedERC20` contract.\nstruct SeedERC20Config {\n    // Reserve erc20 token contract used to purchase seed tokens.\n    IERC20 reserve;\n    // Recipient address for all reserve funds raised when seeding is complete.\n    address recipient;\n    // Price per seed unit denominated in reserve token.\n    uint256 seedPrice;\n    // Total seed units to be mint and sold.\n    // 100% of all seed units must be sold for seeding to complete.\n    // Recommended to keep seed units to a small value (single-triple digits).\n    // The ability for users to buy/sell or not buy/sell dust seed quantities\n    // is likely NOT desired.\n    uint16 seedUnits;\n    // Cooldown duration in blocks for seed/unseed cycles.\n    // Seeding requires locking funds for at least the cooldown period.\n    // Ideally `unseed` is never called and `seed` leaves funds in the contract\n    // until all seed tokens are sold out.\n    // A failed raise cannot make funds unrecoverable, so `unseed` does exist,\n    // but it should be called rarely.\n    uint16 cooldownDuration;\n    // ERC20 name.\n    string name;\n    // ERC20 symbol.\n    string symbol;\n}\n\n/// @title SeedERC20\n/// @notice Facilitates raising seed reserve from an open set of seeders.\n///\n/// When a single seeder address cannot be specified at the time the\n/// `Trust` is constructed a `SeedERC20` will be deployed.\n///\n/// The `SeedERC20` has two phases:\n///\n/// - `Phase.ZERO`: Can swap seed tokens for reserve assets with\n/// `seed` and `unseed`\n/// - `Phase.ONE`: Can redeem seed tokens pro-rata for reserve assets\n///\n/// When the last seed token is distributed the `SeedERC20`\n/// immediately moves to `Phase.ONE` atomically within that\n/// transaction and forwards all reserve to the configured recipient.\n///\n/// For our use-case the recipient is a `Trust` contract but `SeedERC20`\n/// could be used as a mini-fundraise contract for many purposes. In the case\n/// that a recipient is not a `Trust` the recipient will need to be careful not\n/// to fall afoul of KYC and securities law.\n///\n/// @dev Facilitates a pool of reserve funds to forward to a named recipient\n/// contract.\n/// The funds to raise and the recipient is fixed at construction.\n/// The total is calculated as `( seedPrice * seedUnits )` and so is a fixed\n/// amount. It is recommended to keep seedUnits relatively small so that each\n/// unit represents a meaningful contribution to keep dust out of the system.\n///\n/// The contract lifecycle is split into two phases:\n///\n/// - `Phase.ZERO`: the `seed` and `unseed` functions are callable by anyone.\n/// - `Phase.ONE`: holders of the seed erc20 token can redeem any reserve funds\n///   in the contract pro-rata.\n///\n/// When `seed` is called the `SeedERC20` contract takes ownership of reserve\n/// funds in exchange for seed tokens.\n/// When `unseed` is called the `SeedERC20` contract takes ownership of seed\n/// tokens in exchange for reserve funds.\n///\n/// When the last `seed` token is transferred to an external address the\n/// `SeedERC20` contract immediately:\n///\n/// - Moves to `Phase.ONE`, disabling both `seed` and `unseed`\n/// - Transfers the full balance of reserve from itself to the recipient\n///   address.\n///\n/// Seed tokens are standard ERC20 so can be freely transferred etc.\n///\n/// The recipient (or anyone else) MAY transfer reserve back to the `SeedERC20`\n/// at a later date.\n/// Seed token holders can call `redeem` in `Phase.ONE` to burn their tokens in\n/// exchange for pro-rata reserve assets.\ncontract SeedERC20 is Ownable, ERC20, Phased, Cooldown {\n\n    using SafeMath for uint256;\n    using Math for uint256;\n    using SafeERC20 for IERC20;\n\n    // Seed token burn for reserve.\n    event Redeem(\n        // Account burning and receiving.\n        address indexed redeemer,\n        // Number of seed tokens burned.\n        // Number of reserve redeemed for burned seed tokens.\n        // `[seedAmount, reserveAmount]`\n        uint256[2] redeemAmounts\n    );\n\n    /// Reserve erc20 token contract used to purchase seed tokens.\n    IERC20 public immutable reserve;\n    /// Recipient address for all reserve funds raised when seeding is\n    /// complete.\n    address public immutable recipient;\n    /// Price in reserve for a unit of seed token.\n    uint256 public immutable seedPrice;\n\n    /// Sanity checks on configuration.\n    /// Store relevant config as contract state.\n    /// Mint all seed tokens.\n    /// @param config_ All config required to construct the contract.\n    constructor (SeedERC20Config memory config_)\n    public\n    ERC20(config_.name, config_.symbol)\n    Cooldown(config_.cooldownDuration) {\n        require(config_.seedPrice > 0, \"PRICE_0\");\n        require(config_.seedUnits > 0, \"UNITS_0\");\n        require(config_.recipient != address(0), \"RECIPIENT_0\");\n        seedPrice = config_.seedPrice;\n        reserve = config_.reserve;\n        recipient = config_.recipient;\n        _setupDecimals(0);\n        _mint(address(this), config_.seedUnits);\n    }\n\n    /// Take reserve from seeder as `units * seedPrice`.\n    ///\n    /// When the final unit is sold the contract immediately:\n    ///\n    /// - enters `Phase.ONE`\n    /// - transfers its entire reserve balance to the recipient\n    ///\n    /// The desired units may not be available by the time this transaction\n    /// executes. This could be due to high demand, griefing and/or\n    /// front-running on the contract.\n    /// The caller can set a range between `minimumUnits_` and `desiredUnits_`\n    /// to mitigate errors due to the contract running out of stock.\n    /// The maximum available units up to `desiredUnits_` will always be\n    /// processed by the contract. Only the stock of this contract is checked\n    /// against the seed unit range, the caller is responsible for ensuring\n    /// their reserve balance.\n    /// Seeding enforces the cooldown configured in the constructor.\n    /// @param minimumUnits_ The minimum units the caller will accept for a\n    /// successful `seed` call.\n    /// @param desiredUnits_ The maximum units the caller is willing to fund.\n    function seed(uint256 minimumUnits_, uint256 desiredUnits_)\n        external\n        onlyPhase(Phase.ZERO)\n        onlyAfterCooldown\n    {\n        require(desiredUnits_ > 0, \"DESIRED_0\");\n        require(minimumUnits_ <= desiredUnits_, \"MINIMUM_OVER_DESIRED\");\n        uint256 remainingStock_ = balanceOf(address(this));\n        require(minimumUnits_ <= remainingStock_, \"INSUFFICIENT_STOCK\");\n\n        uint256 units_ = desiredUnits_.min(remainingStock_);\n\n        // If `remainingStock_` is less than units then the transfer below will\n        // fail and rollback.\n        if (remainingStock_ == units_) {\n            scheduleNextPhase(uint32(block.number));\n        }\n        _transfer(address(this), msg.sender, units_);\n\n        reserve.safeTransferFrom(\n            msg.sender,\n            address(this),\n            seedPrice.mul(units_)\n        );\n        // Immediately transfer to the recipient.\n        // The transfer is immediate rather than only approving for the\n        // recipient.\n        // This avoids the situation where a seeder immediately redeems their\n        // units before the recipient can withdraw.\n        // It also introduces a failure case where the reserve errors on\n        // transfer. If this fails then everyone can call `unseed` after their\n        // individual cooldowns to exit.\n        if (currentPhase() == Phase.ONE) {\n            reserve.safeTransfer(recipient, reserve.balanceOf(address(this)));\n        }\n    }\n\n    /// Send reserve back to seeder as `( units * seedPrice )`.\n    ///\n    /// Allows addresses to back out until `Phase.ONE`.\n    /// Unlike `redeem` the seed tokens are NOT burned so become newly\n    /// available for another account to `seed`.\n    ///\n    /// In `Phase.ONE` the only way to recover reserve assets is:\n    /// - Wait for the recipient or someone else to deposit reserve assets into\n    ///   this contract.\n    /// - Call redeem and burn the seed tokens\n    ///\n    /// @param units_ Units to unseed.\n    function unseed(uint256 units_)\n        external\n        onlyPhase(Phase.ZERO)\n        onlyAfterCooldown\n    {\n        _transfer(msg.sender, address(this), units_);\n\n        // Reentrant reserve transfer.\n        reserve.safeTransfer(msg.sender, seedPrice.mul(units_));\n    }\n\n    /// Burn seed tokens for pro-rata reserve assets.\n    ///\n    /// ```\n    /// (units * reserve held by seed contract) / total seed token supply\n    /// = reserve transfer to `msg.sender`\n    /// ```\n    ///\n    /// The recipient or someone else must first transfer reserve assets to the\n    /// `SeedERC20` contract.\n    /// The recipient MUST be a TRUSTED contract or third party.\n    /// This contract has no control over the reserve assets once they are\n    /// transferred away at the start of `Phase.ONE`.\n    /// It is the caller's responsibility to monitor the reserve balance of the\n    /// `SeedERC20` contract.\n    ///\n    /// For example, if `SeedERC20` is used as a seeder for a `Trust` contract\n    /// (in this repo) it will receive a refund or refund + fee.\n    /// @param units_ Amount of seed units to burn and redeem for reserve\n    /// assets.\n    function redeem(uint256 units_) external onlyPhase(Phase.ONE) {\n        uint256 _supplyBeforeBurn = totalSupply();\n        _burn(msg.sender, units_);\n\n        uint256 _currentReserveBalance = reserve.balanceOf(address(this));\n        // Guard against someone accidentally calling redeem before any reserve\n        // has been returned.\n        require(_currentReserveBalance > 0, \"RESERVE_BALANCE\");\n        uint256 reserveAmount_ = units_\n            .mul(_currentReserveBalance)\n            .div(_supplyBeforeBurn);\n        emit Redeem(\n            msg.sender,\n            [units_, reserveAmount_]\n        );\n        reserve.safeTransfer(\n            msg.sender,\n            reserveAmount_\n        );\n    }\n\n    /// Sanity check the last phase is `Phase.ONE`.\n    /// @inheritdoc Phased\n    function _beforeScheduleNextPhase(uint32 nextPhaseBlock_)\n        internal\n        override\n        virtual\n    {\n        super._beforeScheduleNextPhase(nextPhaseBlock_);\n        // Phase.ONE is the last phase.\n        assert(currentPhase() < Phase.ONE);\n    }\n}"
    },
    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\nimport \"../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        // solhint-disable-next-line max-line-length\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "contracts/factory/IFactory.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.6.12;\n\npragma experimental ABIEncoderV2;\n\ninterface IFactory {\n    /// Whenever a new child contract is deployed, a `NewContract` event\n    /// containing the new child contract address MUST be emitted.\n    event NewContract(address indexed _contract);\n\n    /// Creates a new child contract.\n    ///\n    /// @param data_ Domain specific data for the child contract constructor.\n    /// @return New child contract address.\n    function createChild(bytes calldata data_) external returns(address);\n\n    /// Checks if address is registered as a child contract of this factory.\n    ///\n    /// Addresses that were not deployed by `createChild` MUST NOT return\n    /// `true` from `isChild`. This is CRITICAL to the security guarantees for\n    /// any contract implementing `IFactory`.\n    ///\n    /// @param maybeChild_ Address to check registration for.\n    /// @return `true` if address was deployed by this contract factory,\n    /// otherwise `false`.\n    function isChild(address maybeChild_) external returns(bool);\n}"
    },
    "@openzeppelin/contracts/utils/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor () internal {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "@openzeppelin/contracts/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow, so we distribute\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../GSN/Context.sol\";\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"
    },
    "contracts/phased/Phased.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.6.12;\n\n/// Defines all possible phases.\n/// `Phased` begins in `Phase.ZERO` and moves through each phase sequentially.\nenum Phase {\n    ZERO,\n    ONE,\n    TWO,\n    THREE,\n    FOUR,\n    FIVE,\n    SIX,\n    SEVEN,\n    EIGHT\n}\n\n/// @title Phased\n/// @notice `Phased` is an abstract contract that defines up to `9` phases that\n/// an implementing contract moves through.\n///\n/// `Phase.ZERO` is always the first phase and does not, and cannot, be set\n/// expicitly. Effectively it is implied that `Phase.ZERO` has been active\n/// since block zero.\n///\n/// Each subsequent phase `Phase.ONE` through `Phase.EIGHT` must be\n/// scheduled sequentially and explicitly at a block number.\n///\n/// Only the immediate next phase can be scheduled with `scheduleNextPhase`,\n/// it is not possible to schedule multiple phases ahead.\n///\n/// Multiple phases can be scheduled in a single block if each scheduled phase\n/// is scheduled for the current block.\n///\n/// Several utility functions and modifiers are provided.\n///\n/// A single hook `_beforeScheduleNextPhase` is provided so contracts can\n/// implement additional phase shift checks.\n///\n/// One event `PhaseShiftScheduled` is emitted each time a phase shift is\n/// scheduled (not when the scheduled phase is reached).\n///\n/// @dev `Phased` contracts have a defined timeline with available\n/// functionality grouped into phases.\n/// Every `Phased` contract starts at `Phase.ZERO` and moves sequentially\n/// through phases `ONE` to `EIGHT`.\n/// Every `Phase` other than `Phase.ZERO` is optional, there is no requirement\n/// that all 9 phases are implemented.\n/// Phases can never be revisited, the inheriting contract always moves through\n/// each achieved phase linearly.\n/// This is enforced by only allowing `scheduleNextPhase` to be called once per\n/// phase.\n/// It is possible to call `scheduleNextPhase` several times in a single block\n/// but the `block.number` for each phase must be reached each time to schedule\n/// the next phase.\n/// Importantly there are events and several modifiers and checks available to\n/// ensure that functionality is limited to the current phase.\n/// The full history of each phase shift block is recorded as a fixed size\n/// array of `uint32`.\nabstract contract Phased {\n    /// Every phase block starts uninitialized.\n    /// Only uninitialized blocks can be set by the phase scheduler.\n    uint32 constant public UNINITIALIZED = uint32(-1);\n\n    /// `PhaseShiftScheduled` is emitted when the next phase is scheduled.\n    event PhaseShiftScheduled(uint32 indexed newPhaseBlock_);\n\n    /// 8 phases each as 32 bits to fit a single 32 byte word.\n    uint32[8] public phaseBlocks = [\n        UNINITIALIZED,\n        UNINITIALIZED,\n        UNINITIALIZED,\n        UNINITIALIZED,\n        UNINITIALIZED,\n        UNINITIALIZED,\n        UNINITIALIZED,\n        UNINITIALIZED\n    ];\n\n    /// Pure function to reduce an array of phase blocks and block number to a\n    /// specific `Phase`.\n    /// The phase will be the highest attained even if several phases have the\n    /// same block number.\n    /// If every phase block is after the block number then `Phase.ZERO` is\n    /// returned.\n    /// If every phase block is before the block number then `Phase.EIGHT` is\n    /// returned.\n    /// @param phaseBlocks_ Fixed array of phase blocks to compare against.\n    /// @param blockNumber_ Determine the relevant phase relative to this block\n    /// number.\n    /// @return The \"current\" phase relative to the block number and phase\n    /// blocks list.\n    function phaseAtBlockNumber(\n        uint32[8] memory phaseBlocks_,\n        uint32 blockNumber_\n    )\n        public\n        pure\n        returns(Phase)\n    {\n        for(uint i_ = 0; i_<8; i_++) {\n            if (blockNumber_ < phaseBlocks_[i_]) {\n                return Phase(i_);\n            }\n        }\n        return Phase(8);\n    }\n\n    /// Pure function to reduce an array of phase blocks and phase to a\n    /// specific block number.\n    /// `Phase.ZERO` will always return block `0`.\n    /// Every other phase will map to a block number in `phaseBlocks_`.\n    /// @param phaseBlocks_ Fixed array of phase blocks to compare against.\n    /// @param phase_ Determine the relevant block number for this phase.\n    /// @return The block number for the phase according to the phase blocks\n    ///         list, as uint32.\n    function blockNumberForPhase(uint32[8] calldata phaseBlocks_, Phase phase_)\n        external\n        pure\n        returns(uint32)\n    {\n        return phase_ > Phase.ZERO ? phaseBlocks_[uint(phase_) - 1] : 0;\n    }\n\n    /// Impure read-only function to return the \"current\" phase from internal\n    /// contract state.\n    /// Simply wraps `phaseAtBlockNumber` for current values of `phaseBlocks`\n    /// and `block.number`.\n    function currentPhase() public view returns (Phase) {\n        return phaseAtBlockNumber(phaseBlocks, uint32(block.number));\n    }\n\n    /// Modifies functions to only be callable in a specific phase.\n    /// @param phase_ Modified functions can only be called during this phase.\n    modifier onlyPhase(Phase phase_) {\n        require(currentPhase() == phase_, \"BAD_PHASE\");\n        _;\n    }\n\n    /// Modifies functions to only be callable in a specific phase OR if the\n    /// specified phase has passed.\n    /// @param phase_ Modified function only callable during or after this\n    /// phase.\n    modifier onlyAtLeastPhase(Phase phase_) {\n        require(currentPhase() >= phase_, \"MIN_PHASE\");\n        _;\n    }\n\n    /// Writes the block for the next phase.\n    /// Only uninitialized blocks can be written to.\n    /// Only the immediate next phase relative to `currentPhase` can be written\n    /// to.\n    /// Emits `PhaseShiftScheduled` with the next phase block.\n    /// @param nextPhaseBlock_ The block for the next phase.\n    function scheduleNextPhase(uint32 nextPhaseBlock_) internal {\n        require(uint32(block.number) <= nextPhaseBlock_, \"NEXT_BLOCK_PAST\");\n        require(nextPhaseBlock_ < UNINITIALIZED, \"NEXT_BLOCK_UNINITIALIZED\");\n\n        // The next index is the current phase because `Phase.ZERO` doesn't\n        // exist as an index.\n        uint nextIndex_ = uint(currentPhase());\n        require(UNINITIALIZED == phaseBlocks[nextIndex_], \"NEXT_BLOCK_SET\");\n\n        _beforeScheduleNextPhase(nextPhaseBlock_);\n        phaseBlocks[nextIndex_] = nextPhaseBlock_;\n\n        emit PhaseShiftScheduled(nextPhaseBlock_);\n    }\n\n    /// Hook called before scheduling the next phase.\n    /// Useful to apply additional constraints or state changes on a phase\n    /// change.\n    /// Note this is called when scheduling the phase change, not on the block\n    /// the phase change occurs.\n    /// This is called before the phase change so that all functionality that\n    /// is behind a phase gate is still available at the moment of applying the\n    /// hook for scheduling the next phase.\n    /// @param nextPhaseBlock_ The block for the next phase.\n    function _beforeScheduleNextPhase(uint32 nextPhaseBlock_)\n        internal\n        virtual\n    { } //solhint-disable-line no-empty-blocks\n}"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.2 <0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../utils/EnumerableSet.sol\";\nimport \"../utils/Address.sol\";\nimport \"../GSN/Context.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControl is Context {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using Address for address;\n\n    struct RoleData {\n        EnumerableSet.AddressSet members;\n        bytes32 adminRole;\n    }\n\n    mapping (bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view returns (bool) {\n        return _roles[role].members.contains(account);\n    }\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) public view returns (uint256) {\n        return _roles[role].members.length();\n    }\n\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) public view returns (address) {\n        return _roles[role].members.at(index);\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) public virtual {\n        require(hasRole(_roles[role].adminRole, _msgSender()), \"AccessControl: sender must be an admin to grant\");\n\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) public virtual {\n        require(hasRole(_roles[role].adminRole, _msgSender()), \"AccessControl: sender must be an admin to revoke\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) public virtual {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        emit RoleAdminChanged(role, _roles[role].adminRole, adminRole);\n        _roles[role].adminRole = adminRole;\n    }\n\n    function _grantRole(bytes32 role, address account) private {\n        if (_roles[role].members.add(account)) {\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    function _revokeRole(bytes32 role, address account) private {\n        if (_roles[role].members.remove(account)) {\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20Burnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../../GSN/Context.sol\";\nimport \"./ERC20.sol\";\n\n/**\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\n * tokens and those that they have an allowance for, in a way that can be\n * recognized off-chain (via event analysis).\n */\nabstract contract ERC20Burnable is Context, ERC20 {\n    using SafeMath for uint256;\n\n    /**\n     * @dev Destroys `amount` tokens from the caller.\n     *\n     * See {ERC20-_burn}.\n     */\n    function burn(uint256 amount) public virtual {\n        _burn(_msgSender(), amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\n     * allowance.\n     *\n     * See {ERC20-_burn} and {ERC20-allowance}.\n     *\n     * Requirements:\n     *\n     * - the caller must have allowance for ``accounts``'s tokens of at least\n     * `amount`.\n     */\n    function burnFrom(address account, uint256 amount) public virtual {\n        uint256 decreasedAllowance = allowance(account, _msgSender()).sub(amount, \"ERC20: burn amount exceeds allowance\");\n\n        _approve(account, _msgSender(), decreasedAllowance);\n        _burn(account, amount);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping (bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\n\n            bytes32 lastvalue = set._values[lastIndex];\n\n            // Move the last value to the index where the value to delete is\n            set._values[toDeleteIndex] = lastvalue;\n            // Update the index for the moved value\n            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        require(set._values.length > index, \"EnumerableSet: index out of bounds\");\n        return set._values[index];\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(value)));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(value)));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(value)));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint256(_at(set._inner, index)));\n    }\n\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n}\n"
    },
    "contracts/pool/IRightsManager.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity 0.6.12;\n\npragma experimental ABIEncoderV2;\n\n// Mirrors `Rights` from Balancer `configurable-rights-pool` repo.\n// As we do not include balancer contracts as a dependency, we need to ensure\n// that any calculations or values that cross the interface to their system are\n// identical.\n// solhint-disable-next-line max-line-length\n// https://github.com/balancer-labs/configurable-rights-pool/blob/5bd63657ac71a9e5f8484ea561de572193b3317b/libraries/RightsManager.sol#L29\nstruct Rights {\n    bool canPauseSwapping;\n    bool canChangeSwapFee;\n    bool canChangeWeights;\n    bool canAddRemoveTokens;\n    bool canWhitelistLPs;\n    bool canChangeCap;\n}"
    },
    "contracts/pool/ICRPFactory.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity 0.6.12;\n\npragma experimental ABIEncoderV2;\n\nimport { PoolParams } from \"./IConfigurableRightsPool.sol\";\nimport { Rights } from \"./IRightsManager.sol\";\n\n/// Mirrors the Balancer `CRPFactory` functions relevant to\n/// bootstrapping a pool. This is the minimal interface required for\n/// `RedeemableERC20Pool` to function, much of the Balancer contract is elided\n/// intentionally. Clients should use Balancer code directly.\n// solhint-disable-next-line max-line-length\n/// https://github.com/balancer-labs/configurable-rights-pool/blob/5bd63657ac71a9e5f8484ea561de572193b3317b/contracts/CRPFactory.sol#L27\ninterface ICRPFactory {\n    // solhint-disable-next-line max-line-length\n    // https://github.com/balancer-labs/configurable-rights-pool/blob/5bd63657ac71a9e5f8484ea561de572193b3317b/contracts/CRPFactory.sol#L50\n    function newCrp(\n        address factoryAddress,\n        PoolParams calldata poolParams,\n        Rights calldata rights\n    )\n    external\n    returns (address);\n}"
    },
    "contracts/pool/IConfigurableRightsPool.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity 0.6.12;\n\npragma experimental ABIEncoderV2;\n\n/// Mirrors the `PoolParams` struct normally internal to a Balancer\n/// `ConfigurableRightsPool`.\n/// If nothing else, this fixes errors that prevent slither from compiling when\n/// running the security scan.\n// solhint-disable-next-line max-line-length\n/// https://github.com/balancer-labs/configurable-rights-pool/blob/5bd63657ac71a9e5f8484ea561de572193b3317b/contracts/ConfigurableRightsPool.sol#L47\nstruct PoolParams {\n    string poolTokenSymbol;\n    string poolTokenName;\n    address[] constituentTokens;\n    uint[] tokenBalances;\n    uint[] tokenWeights;\n    uint swapFee;\n}\n\n/// Mirrors the Balancer `ConfigurableRightsPool` functions relevant to\n/// bootstrapping a pool. This is the minimal interface required for\n/// `RedeemableERC20Pool` to function, much of the Balancer contract is elided\n/// intentionally. Clients should use Balancer code directly.\n// solhint-disable-next-line max-line-length\n/// https://github.com/balancer-labs/configurable-rights-pool/blob/5bd63657ac71a9e5f8484ea561de572193b3317b/contracts/ConfigurableRightsPool.sol#L41\ninterface IConfigurableRightsPool {\n    // solhint-disable-next-line max-line-length\n    // https://github.com/balancer-labs/configurable-rights-pool/blob/5bd63657ac71a9e5f8484ea561de572193b3317b/contracts/ConfigurableRightsPool.sol#L61\n    function bPool() external view returns (address);\n\n    // solhint-disable-next-line max-line-length\n    // https://github.com/balancer-labs/configurable-rights-pool/blob/5bd63657ac71a9e5f8484ea561de572193b3317b/contracts/ConfigurableRightsPool.sol#L60\n    function bFactory() external view returns (address);\n\n    // solhint-disable-next-line max-line-length\n    // https://github.com/balancer-labs/configurable-rights-pool/blob/5bd63657ac71a9e5f8484ea561de572193b3317b/contracts/ConfigurableRightsPool.sol#L318\n    function createPool(\n        uint initialSupply,\n        uint minimumWeightChangeBlockPeriodParam,\n        uint addTokenTimeLockInBlocksParam\n    ) external;\n\n    // solhint-disable-next-line max-line-length\n    // https://github.com/balancer-labs/configurable-rights-pool/blob/5bd63657ac71a9e5f8484ea561de572193b3317b/contracts/ConfigurableRightsPool.sol#L393\n    function updateWeightsGradually(\n        uint[] calldata newWeights,\n        uint startBlock,\n        uint endBlock\n    ) external;\n\n    // solhint-disable-next-line max-line-length\n    // https://github.com/balancer-labs/configurable-rights-pool/blob/5bd63657ac71a9e5f8484ea561de572193b3317b/contracts/ConfigurableRightsPool.sol#L581\n    function exitPool(uint poolAmountIn, uint[] calldata minAmountsOut)\n        external;\n}"
    },
    "contracts/pool/IBalancerConstants.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity 0.6.12;\n\n// Mirrors all the constants from Balancer `configurable-rights-pool` repo.\n// As we do not include balancer contracts as a dependency, we need to ensure\n// that any calculations or values that cross the interface to their system are\n// identical.\n// solhint-disable-next-line max-line-length\n// https://github.com/balancer-labs/configurable-rights-pool/blob/5bd63657ac71a9e5f8484ea561de572193b3317b/libraries/BalancerConstants.sol#L9\nlibrary IBalancerConstants {\n    uint public constant BONE = 10**18;\n    uint public constant MIN_WEIGHT = BONE;\n    uint public constant MAX_WEIGHT = BONE * 50;\n    uint public constant MAX_TOTAL_WEIGHT = BONE * 50;\n    uint public constant MIN_BALANCE = BONE / 10**6;\n    uint public constant MAX_BALANCE = BONE * 10**12;\n    uint public constant MIN_POOL_SUPPLY = BONE * 100;\n    uint public constant MAX_POOL_SUPPLY = BONE * 10**9;\n    uint public constant MIN_FEE = BONE / 10**6;\n    uint public constant MAX_FEE = BONE / 10;\n    uint public constant EXIT_FEE = 0;\n    uint public constant MAX_IN_RATIO = BONE / 2;\n    uint public constant MAX_OUT_RATIO = (BONE / 3) + 1 wei;\n    uint public constant MIN_ASSET_LIMIT = 2;\n    uint public constant MAX_ASSET_LIMIT = 8;\n    uint public constant MAX_UINT = uint(-1);\n}"
    },
    "contracts/cooldown/Cooldown.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.6.12;\n\n/// @title Cooldown\n/// @notice `Cooldown` is an abstract contract that rate limits functions on\n/// the contract per `msg.sender`.\n///\n/// Each time a function with the `onlyAfterCooldown` modifier is called the\n/// `msg.sender` must wait N blocks before calling any modified function.\n///\n/// This does nothing to prevent sybils who can generate an arbitrary number of\n/// `msg.sender` values in parallel to spam a contract.\n///\n/// `Cooldown` is intended to prevent rapid state cycling to grief a contract,\n/// such as rapidly locking and unlocking a large amount of capital in the\n/// `SeedERC20` contract.\n///\n/// Requiring a lock/deposit of significant economic stake that sybils will not\n/// have access to AND applying a cooldown IS a sybil mitigation. The economic\n/// stake alone is NOT sufficient if gas is cheap as sybils can cycle the same\n/// stake between each other. The cooldown alone is NOT sufficient as many\n/// sybils can be created, each as a new `msg.sender`.\n///\n/// @dev Base for anything that enforces a cooldown delay on functions.\n/// Cooldown requires a minimum time in blocks to elapse between actions that\n/// cooldown. The modifier `onlyAfterCooldown` both enforces and triggers the\n/// cooldown. There is a single cooldown across all functions per-contract\n/// so any function call that requires a cooldown will also trigger it for\n/// all other functions.\n///\n/// Cooldown is NOT an effective sybil resistance alone, as the cooldown is\n/// per-address only. It is always possible for many accounts to be created\n/// to spam a contract with dust in parallel.\n/// Cooldown is useful to stop a single account rapidly cycling contract\n/// state in a way that can be disruptive to peers. Cooldown works best when\n/// coupled with economic stake associated with each state change so that\n/// peers must lock capital during the cooldown. Cooldown tracks the first\n/// `msg.sender` it sees for a call stack so cooldowns are enforced across\n/// reentrant code.\nabstract contract Cooldown {\n    /// Time in blocks to restrict access to modified functions.\n    uint16 public immutable cooldownDuration;\n\n    /// Every address has its own cooldown state.\n    mapping (address => uint256) public cooldowns;\n    address private caller;\n\n    /// The cooldown duration is global to the contract.\n    /// Cooldown duration must be greater than 0.\n    /// @param cooldownDuration_ The global cooldown duration.\n    constructor(uint16 cooldownDuration_) public {\n        require(cooldownDuration_ > 0, \"COOLDOWN_0\");\n        cooldownDuration = cooldownDuration_;\n    }\n\n    /// Modifies a function to enforce the cooldown for `msg.sender`.\n    /// Saves the original caller so that cooldowns are enforced across\n    /// reentrant code.\n    modifier onlyAfterCooldown() {\n        address caller_ = caller == address(0) ? caller = msg.sender : caller;\n        require(cooldowns[caller_] <= block.number, \"COOLDOWN\");\n        // Every action that requires a cooldown also triggers a cooldown.\n        cooldowns[caller_] = block.number + cooldownDuration;\n        _;\n        delete caller;\n    }\n}"
    },
    "contracts/tier/ERC20TransferTier.sol": {
      "content": "// SPDX-License-Identifier: CAL\n\npragma solidity 0.6.12;\n\nimport { SafeMath } from \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport { TierUtil } from \"../libraries/TierUtil.sol\";\nimport { ValueTier } from \"./ValueTier.sol\";\nimport \"./ReadWriteTier.sol\";\n\n/// @title ERC20TransferTier\n/// @notice `ERC20TransferTier` inherits from `ReadWriteTier`.\n///\n/// In addition to the standard accounting it requires that users transfer\n/// erc20 tokens to achieve a tier.\n///\n/// Data is ignored, the only requirement is that the user has approved\n/// sufficient balance to gain the next tier.\n///\n/// To avoid griefing attacks where accounts remove tiers from arbitrary third\n/// parties, we `require(msg.sender == account_);` when a tier is removed.\n/// When a tier is added the `msg.sender` is responsible for payment.\n///\n/// The 8 values for gainable tiers and erc20 contract must be set upon\n/// construction and are immutable.\n///\n/// The `_afterSetTier` simply transfers the diff between the start/end tier\n/// to/from the user as required.\n///\n/// If a user sends erc20 tokens directly to the contract without calling\n/// `setTier` the FUNDS ARE LOST.\n///\n/// @dev The `ERC20TransferTier` takes ownership of an erc20 balance by\n/// transferring erc20 token to itself. The `msg.sender` must pay the\n/// difference on upgrade; the tiered address receives refunds on downgrade.\n/// This allows users to \"gift\" tiers to each other.\n/// As the transfer is a state changing event we can track historical block\n/// times.\n/// As the tiered address moves up/down tiers it sends/receives the value\n/// difference between its current tier only.\n///\n/// The user is required to preapprove enough erc20 to cover the tier change or\n/// they will fail and lose gas.\n///\n/// `ERC20TransferTier` is useful for:\n/// - Claims that rely on historical holdings so the tiered address\n///   cannot simply \"flash claim\"\n/// - Token demand and lockup where liquidity (trading) is a secondary goal\n/// - erc20 tokens without additonal restrictions on transfer\ncontract ERC20TransferTier is ReadWriteTier, ValueTier {\n    using SafeERC20 for IERC20;\n\n    IERC20 public immutable erc20;\n\n    /// @param erc20_ The erc20 token contract to transfer balances\n    /// from/to during `setTier`.\n    /// @param tierValues_ 8 values corresponding to minimum erc20\n    /// balances for tiers ONE through EIGHT.\n    constructor(IERC20 erc20_, uint256[8] memory tierValues_)\n        public\n        ValueTier(tierValues_)\n    {\n        erc20 = erc20_;\n    }\n\n    /// Transfers balances of erc20 from/to the tiered account according to the\n    /// difference in values. Any failure to transfer in/out will rollback the\n    /// tier change. The tiered account must ensure sufficient approvals before\n    /// attempting to set a new tier.\n    /// The `msg.sender` is responsible for paying the token cost of a tier\n    /// increase.\n    /// The tiered account is always the recipient of a refund on a tier\n    /// decrease.\n    /// @inheritdoc ReadWriteTier\n    function _afterSetTier(\n        address account_,\n        ITier.Tier startTier_,\n        ITier.Tier endTier_,\n        bytes memory\n    )\n        internal\n        override\n    {\n        // As _anyone_ can call `setTier` we require that `msg.sender` and\n        // `account_` are the same if the end tier is lower.\n        // Anyone can increase anyone else's tier as the `msg.sender` is\n        // responsible to pay the difference.\n        if (endTier_ <= startTier_) {\n            require(msg.sender == account_, \"DELEGATED_TIER_LOSS\");\n        }\n\n        // Handle the erc20 transfer.\n        // Convert the start tier to an erc20 amount.\n        uint256 startValue_ = tierToValue(startTier_);\n        // Convert the end tier to an erc20 amount.\n        uint256 endValue_ = tierToValue(endTier_);\n\n        // Short circuit if the values are the same for both tiers.\n        if (endValue_ == startValue_) {\n            return;\n        }\n        if (endValue_ > startValue_) {\n            // Going up, take ownership of erc20 from the `msg.sender`.\n            erc20.safeTransferFrom(msg.sender, address(this), SafeMath.sub(\n                endValue_,\n                startValue_\n            ));\n        } else {\n            // Going down, process a refund for the tiered account.\n            erc20.safeTransfer(account_, SafeMath.sub(\n                startValue_,\n                endValue_\n            ));\n        }\n    }\n}"
    },
    "contracts/tier/ValueTier.sol": {
      "content": "// SPDX-License-Identifier: CAL\n\npragma solidity 0.6.12;\n\nimport { ITier } from \"./ITier.sol\";\n\n/// @title ValueTier\n///\n/// @dev A contract that is `ValueTier` expects to derive tiers from explicit\n/// values. For example an address must send or hold an amount of something to\n/// reach a given tier.\n/// Anything with predefined values that map to tiers can be a `ValueTier`.\n///\n/// Note that `ValueTier` does NOT implement `ITier`.\n/// `ValueTier` does include state however, to track the `tierValues` so is not\n/// a library.\ncontract ValueTier {\n    uint256 private immutable tierOne;\n    uint256 private immutable tierTwo;\n    uint256 private immutable tierThree;\n    uint256 private immutable tierFour;\n    uint256 private immutable tierFive;\n    uint256 private immutable tierSix;\n    uint256 private immutable tierSeven;\n    uint256 private immutable tierEight;\n\n    /// Set the `tierValues` on construction to be referenced immutably.\n    constructor(uint256[8] memory tierValues_) public {\n        tierOne = tierValues_[0];\n        tierTwo = tierValues_[1];\n        tierThree = tierValues_[2];\n        tierFour = tierValues_[3];\n        tierFive = tierValues_[4];\n        tierSix = tierValues_[5];\n        tierSeven = tierValues_[6];\n        tierEight = tierValues_[7];\n    }\n\n    /// Complements the default solidity accessor for `tierValues`.\n    /// Returns all the values in a list rather than requiring an index be\n    /// specified.\n    /// @return tierValues_ The immutable `tierValues`.\n    function tierValues() public view returns(uint256[8] memory tierValues_) {\n        tierValues_[0] = tierOne;\n        tierValues_[1] = tierTwo;\n        tierValues_[2] = tierThree;\n        tierValues_[3] = tierFour;\n        tierValues_[4] = tierFive;\n        tierValues_[5] = tierSix;\n        tierValues_[6] = tierSeven;\n        tierValues_[7] = tierEight;\n        return tierValues_;\n    }\n\n    /// Converts a Tier to the minimum value it requires.\n    /// `Tier.ZERO` is always value 0 as it is the fallback.\n    function tierToValue(ITier.Tier tier_) internal view returns(uint256) {\n        return tier_ > ITier.Tier.ZERO ? tierValues()[uint256(tier_) - 1] : 0;\n    }\n\n    /// Converts a value to the maximum Tier it qualifies for.\n    function valueToTier(uint256 value_) internal view returns(ITier.Tier) {\n        for (uint256 i = 0; i < 8; i++) {\n            if (value_ < tierValues()[i]) {\n                return ITier.Tier(i);\n            }\n        }\n        return ITier.Tier.EIGHT;\n    }\n}"
    },
    "contracts/tier/ReadWriteTier.sol": {
      "content": "// SPDX-License-Identifier: CAL\n\npragma solidity 0.6.12;\n\nimport { ITier } from \"./ITier.sol\";\nimport { TierUtil } from \"../libraries/TierUtil.sol\";\n\n/// @title ReadWriteTier\n/// @notice `ReadWriteTier` is a base contract that other contracts are\n/// expected to inherit.\n///\n/// It handles all the internal accounting and state changes for `report`\n/// and `setTier`.\n///\n/// It calls an `_afterSetTier` hook that inheriting contracts can override to\n/// enforce tier requirements.\n///\n/// @dev ReadWriteTier can `setTier` in addition to generating reports.\n/// When `setTier` is called it automatically sets the current blocks in the\n/// report for the new tiers. Lost tiers are scrubbed from the report as tiered\n/// addresses move down the tiers.\ncontract ReadWriteTier is ITier {\n    /// account => reports\n    mapping(address => uint256) public reports;\n\n    /// Either fetch the report from storage or return UNINITIALIZED.\n    /// @inheritdoc ITier\n    function report(address account_)\n        public\n        virtual\n        override\n        view\n        returns (uint256)\n    {\n        // Inequality here to silence slither warnings.\n        return reports[account_] > 0\n            ? reports[account_]\n            : TierUtil.UNINITIALIZED;\n    }\n\n    /// Errors if the user attempts to return to the `Tier.ZERO` tier.\n    /// Updates the report from `report` using default `TierUtil` logic.\n    /// Calls `_afterSetTier` that inheriting contracts SHOULD override to\n    /// enforce status requirements.\n    /// Emits `TierChange` event.\n    /// @inheritdoc ITier\n    function setTier(\n        address account_,\n        Tier endTier_,\n        bytes memory data_\n    )\n        external virtual override\n    {\n        // The user must move to at least `Tier.ONE`.\n        // The `Tier.ZERO` status is reserved for users that have never\n        // interacted with the contract.\n        require(endTier_ != Tier.ZERO, \"SET_ZERO_TIER\");\n\n        uint256 report_ = report(account_);\n\n        ITier.Tier startTier_ = TierUtil.tierAtBlockFromReport(\n            report_,\n            block.number\n        );\n\n        reports[account_] = TierUtil.updateReportWithTierAtBlock(\n            report_,\n            startTier_,\n            endTier_,\n            block.number\n        );\n\n        // Emit this event for ITier.\n        emit TierChange(account_, startTier_, endTier_);\n\n        // Call the `_afterSetTier` hook to allow inheriting contracts\n        // to enforce requirements.\n        // The inheriting contract MUST `require` or otherwise\n        // enforce its needs to rollback a bad status change.\n        _afterSetTier(account_, startTier_, endTier_, data_);\n    }\n\n    /// Inheriting contracts SHOULD override this to enforce requirements.\n    ///\n    /// All the internal accounting and state changes are complete at\n    /// this point.\n    /// Use `require` to enforce additional requirements for tier changes.\n    ///\n    /// @param account_ The account with the new tier.\n    /// @param startTier_ The tier the account had before this update.\n    /// @param endTier_ The tier the account will have after this update.\n    /// @param data_ Additional arbitrary data to inform update requirements.\n    // Slither false positive. This is intended to overridden.\n    // https://github.com/crytic/slither/issues/929\n    // slither-disable-next-line dead-code\n    function _afterSetTier(\n        address account_,\n        Tier startTier_,\n        Tier endTier_,\n        bytes memory data_\n    )\n        internal virtual\n    { } // solhint-disable-line no-empty-blocks\n}"
    },
    "contracts/tier/VerifyTier.sol": {
      "content": "// SPDX-License-Identifier: CAL\n\npragma solidity 0.6.12;\n\npragma experimental ABIEncoderV2;\n\nimport \"./ReadOnlyTier.sol\";\nimport { State, Status, Verify } from \"../verify/Verify.sol\";\nimport \"../libraries/TierUtil.sol\";\n\n/// @title VerifyTier\n///\n/// @dev A contract that is `VerifyTier` expects to derive tiers from the time\n/// the account was approved by the underlying `Verify` contract. The approval\n/// block numbers defer to `State.since` returned from `Verify.state`.\ncontract VerifyTier is ReadOnlyTier {\n    Verify public immutable verify;\n\n    /// Sets the `verify` contract immutably.\n    constructor(Verify verify_) public {\n        verify = verify_;\n    }\n\n    /// Every tier will be the `State.since` block if `account_` is approved\n    /// otherwise every tier will be uninitialized.\n    /// @inheritdoc ITier\n    function report(address account_) public override view returns (uint256) {\n        State memory state_ = verify.state(account_);\n        if (\n            // This is comparing an enum variant so it must be equal.\n            // slither-disable-next-line incorrect-equality\n            verify.statusAtBlock(\n                state_,\n                uint32(block.number)\n            ) == Status.Approved) {\n            return TierUtil.updateBlocksForTierRange(\n                0,\n                Tier.ZERO,\n                Tier.EIGHT,\n                state_.approvedSince\n            );\n        }\n        else {\n            return uint256(-1);\n        }\n    }\n}"
    },
    "contracts/tier/ReadOnlyTier.sol": {
      "content": "// SPDX-License-Identifier: CAL\n\npragma solidity 0.6.12;\n\nimport { ITier } from \"./ITier.sol\";\nimport { TierUtil } from \"../libraries/TierUtil.sol\";\n\n/// @title ReadOnlyTier\n/// @notice `ReadOnlyTier` is a base contract that other contracts\n/// are expected to inherit.\n///\n/// It does not allow `setStatus` and expects `report` to derive from\n/// some existing onchain data.\n///\n/// @dev A contract inheriting `ReadOnlyTier` cannot call `setTier`.\n///\n/// `ReadOnlyTier` is abstract because it does not implement `report`.\n/// The expectation is that `report` will derive tiers from some\n/// external data source.\nabstract contract ReadOnlyTier is ITier {\n    /// Always reverts because it is not possible to set a read only tier.\n    /// @inheritdoc ITier\n    function setTier(\n        address,\n        Tier,\n        bytes memory\n    )\n        external override\n    {\n        revert(\"SET_TIER\");\n    }\n}"
    },
    "contracts/verify/Verify.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.6.12;\n\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\n\n/// Summary status derived from a `State` by comparing the `xSince` times\n/// against a specific block number.\nenum Status {\n    // Either no Status has ever been held or it was removed.\n    Nil,\n    // The account and associated ID has been added, pending verification.\n    Added,\n    // The associated ID has been reviewed and verified.\n    Approved,\n    // The associated ID has been reviewed and banned.\n    // (even if previously approved)\n    Banned\n}\n\n/// Records the block a verify session reaches each status.\n/// If a status is not reached it is left as UNINITIALIZED, i.e. 0xFFFFFFFF.\n/// Most accounts will never be banned so most accounts will never reach every\n/// status, which is a good thing.\nstruct State {\n    uint256 id;\n    uint32 addedSince;\n    uint32 approvedSince;\n    uint32 bannedSince;\n}\n\n/// @title Verify\n/// Trust-minimised contract to record the state of some verification process.\n/// When some off-chain identity is to be reified on chain there is inherently\n/// some multi-party, multi-faceted trust relationship. For example, the DID\n/// (Decentralized Identifiers) specification from W3C outlines that the\n/// controller and the subject of an identity are two different entities.\n///\n/// This is because self-identification is always problematic to the point of\n/// being uselessly unbelievable.\n///\n/// For example, I can simply say \"I am the queen of England\" and what\n/// onchain mechanism could possibly check, let alone stop me?\n/// The same problem exists in any situation where some priviledge or right is\n/// associated with identity. Consider passports, driver's licenses,\n/// celebrity status, age, health, accredited investor, social media account,\n/// etc. etc.\n///\n/// Typically crypto can't and doesn't want to deal with this issue. The usual\n/// scenario is that some system demands personal information, which leads to:\n///\n/// - Data breaches that put individual's safety at risk. Consider the December\n///   2020 leak from Ledger that dumped 270 000 home addresses and phone\n///   numbers, and another million emails, of hardware wallet owners on a\n///   public forum.\n/// - Discriminatory access, undermining an individual's self-sovereign right\n///   to run a full node, self-host a GUI and broadcast transactions onchain.\n///   Consider the dydx airdrop of 2021 where metadata about a user's access\n///   patterns logged on a server were used to deny access to presumed\n///   Americans over regulatory fears.\n/// - An entrenched supply chain of centralized actors from regulators, to\n///   government databases, through KYC corporations, platforms, etc. each of\n///   which holds an effective monopoly over, and ability to manipulate user's\n///   \"own\" identity.\n///\n/// These examples and others are completely antithetical to and undermine the\n/// safety of an opt-in, permissionless system based on pseudonomous actors\n/// self-signing actions into a shared space.\n///\n/// That said, one can hardly expect a permissionless pseudonomous system\n/// founded on asynchronous value transfers to succeed without at least some\n/// concept of curation and reputation.\n///\n/// Anon, will you invest YOUR money in anon's project?\n///\n/// Clearly for every defi blue chip there are 10 000 scams and nothing onchain\n/// can stop a scam, this MUST happen at the social layer.\n///\n/// Rain protocol is agnostic to how this verification happens. A government\n/// regulator is going to want a government issued ID cross-referenced against\n/// international sanctions. A fan of some social media influencer wants to\n/// see a verified account on that platform. An open source software project\n/// should show a github profile. A security token may need evidence from an\n/// accountant showing accredited investor status. There are so many ways in\n/// which BOTH sides of a fundraise may need to verify something about\n/// themselves to each other via a THIRD PARTY that Rain cannot assume much.\n///\n/// The trust model and process for Rain verification is:\n///\n/// - There are many `Verify` contracts, each represents a specific\n///   verification method with a (hopefully large) set of possible reviewers.\n/// - The verifyee compiles some evidence that can be referenced by ID in some\n///   relevant system. It could be a session ID in a KYC provider's database or\n///   a tweet from a verified account, etc. The ID is a `uint256` so should be\n///   enough to fit just about any system ID, it is large enough to fit a hash,\n///   2x UUIDs or literally any sequential ID.\n/// - The verifyee calls `add` _for themselves_ to include their ID under their\n///   account, after which they _cannot change_ their submission without\n///   appealing to someone who can remove. This costs gas, so why don't we\n///   simply ask the user to sign something and have an approver verify the\n///   signed data? Because we want to leverage both the censorship resistance\n///   and asynchronous nature of the underlying blockchain. Assuming there are\n///   N possible approvers, we want ANY 1 of those N approvers to be able to\n///   review and approve an application. If the user is forced to submit their\n///   application directly to one SPECIFIC approver we lose this property. In\n///   the gasless model the user must then rely on their specific approver both\n///   being online and not to censor the request. It's also possible that many\n///   accounts add the same ID, after all the ID will be public onchain, so it\n///   is important for approvers to verify the PAIRING between account and ID.\n/// - ANY account with the `APPROVER` role can review the added ID against the\n///   records in the system referenced by the ID. IF the ID is valid then the\n///   `approve` function should be called by the approver.\n/// - ANY account with the `BANNER` role can veto either an add OR a prior\n///   approval. In the case of a false positive, i.e. where an account was\n///   mistakenly approved, an appeal can be made to a banner to update the\n///   status. Bad accounts SHOULD BE BANNED NOT REMOVED. When an account is\n///   removed, its onchain state is once again open for the attacker to\n///   resubmit a new fraudulent session ID and potentially be reapproved.\n///   Once an account is banned, any attempt by the account holder to change\n///   their session ID, or an approver to approve will be rejected. Downstream\n///   consumers of a `State` MUST check for an existing ban.\n///   - ANY account with the `REMOVER` role can scrub the `State` from an\n///   account. Of course, this is a blockchain so the state changes are all\n///   still visible to full nodes and indexers in historical data, in both the\n///   onchain history and the event logs for each state change. This allows an\n///   account to appeal to a remover in the case of a MISTAKEN BAN or also in\n///   the case of a MISTAKEN ADD (e.g. wrong ID value), effecting a\n///   \"hard reset\" at the contract storage level.\n///\n/// Banning some account with an invalid session is NOT required. It is\n/// harmless for an added session to remain as `Status.Added` indefinitely.\n/// For as long as no approver decides to approve some invalid added session it\n/// MUST be treated as equivalent to a ban by downstream contracts.\n///\n/// Rain uses standard Open Zeppelin `AccessControl` and is agnostic to how the\n/// approver/remover/banner roles and associated admin roles are managed.\n/// Ideally the more credibly neutral qualified parties assigend to each role\n/// for each `Verify` contract the better. This improves the censorship\n/// resistance of the verification process and the responsiveness of the\n/// end-user experience.\n///\n/// Ideally the admin account assigned at deployment would renounce their admin\n/// rights after establishing a more granular and appropriate set of accounts\n/// with each specific role.\ncontract Verify is AccessControl {\n\n    /// Any state never held is UNINITIALIZED.\n    /// Note that as per default evm an unset state is 0 so always check the\n    /// `addedSince` block on a `State` before trusting an equality check on\n    /// any other block number.\n    /// (i.e. removed or never added)\n    uint32 constant public UNINITIALIZED = uint32(-1);\n\n    /// Emitted when a session ID is first associated with an account.\n    event Add(address indexed account, uint256 indexed id);\n    /// Emitted when a previously added account is approved.\n    event Approve(address indexed account);\n    /// Emitted when an added or approved account is banned.\n    event Ban(address indexed account);\n    /// Emitted when an account is scrubbed from blockchain state.\n    event Remove(address indexed account);\n\n    /// Admin role for `APPROVER`.\n    bytes32 public constant APPROVER_ADMIN = keccak256(\"APPROVER_ADMIN\");\n    /// Role for `APPROVER`.\n    bytes32 public constant APPROVER = keccak256(\"APPROVER\");\n\n    /// Admin role for `REMOVER`.\n    bytes32 public constant REMOVER_ADMIN = keccak256(\"REMOVER_ADMIN\");\n    /// Role for `REMOVER`.\n    bytes32 public constant REMOVER = keccak256(\"REMOVER\");\n\n    /// Admin role for `BANNER`.\n    bytes32 public constant BANNER_ADMIN = keccak256(\"BANNER_ADMIN\");\n    /// Role for `BANNER`.\n    bytes32 public constant BANNER = keccak256(\"BANNER\");\n\n    // Account => State\n    mapping (address => State) public states;\n\n    /// Defines RBAC logic for each role under Open Zeppelin.\n    constructor (address admin_) public {\n        _setRoleAdmin(APPROVER, APPROVER_ADMIN);\n        _setupRole(APPROVER_ADMIN, admin_);\n        _setRoleAdmin(REMOVER, REMOVER_ADMIN);\n        _setupRole(REMOVER_ADMIN, admin_);\n        _setRoleAdmin(BANNER, BANNER_ADMIN);\n        _setupRole(BANNER_ADMIN, admin_);\n\n        // This is at the end of the constructor because putting it at the\n        // start seems to break the source map from the compiler \n        require(admin_ != address(0), \"0_ACCOUNT\");\n    }\n\n    /// Typed accessor into states.\n    function state(address account_) external view returns (State memory) {\n        return states[account_];\n    }\n\n    /// Derives a single `Status` from a `State` and a reference block number.\n    function statusAtBlock(State calldata state_, uint32 blockNumber)\n        external\n        pure\n        returns (Status)\n    {\n        // The state hasn't even been added so is picking up block zero as the\n        // evm fallback value. In this case if we checked other blocks using\n        // a `<=` equality they would incorrectly return `true` always due to\n        // also having a `0` fallback value.\n        if (state_.addedSince == 0) {\n            return Status.Nil;\n        }\n        // Banned takes priority over everything.\n        else if (state_.bannedSince <= blockNumber) {\n            return Status.Banned;\n        }\n        // Approved takes priority over added.\n        else if (state_.approvedSince <= blockNumber) {\n            return Status.Approved;\n        }\n        // Added is lowest priority.\n        else if (state_.addedSince <= blockNumber) {\n            return Status.Added;\n        }\n        // The `addedSince` block is after `blockNumber` so `Status` is nil\n        // relative to `blockNumber`.\n        else {\n            return Status.Nil;\n        }\n    }\n\n    // An account adds their own verification session `id_`.\n    // Internally `msg.sender` is used as delegated `add` is not supported.\n    function add(uint256 id_) external {\n        // Accounts may NOT change their ID once added.\n        // This restriction is the main reason delegated add is not supported\n        // as it would lead to griefing.\n        // A mistaken add requires an appeal to a REMOVER to restart the\n        // process OR a new `msg.sender` (i.e. different wallet address).\n        require(id_ != 0, \"0_ID\");\n        // The awkward < 1 here is to silence slither complaining about\n        // equality checks against `0`. The intent is to ensure that\n        // `addedSince` is not already set before we set it.\n        require(states[msg.sender].addedSince < 1, \"PRIOR_ADD\");\n        states[msg.sender] = State(\n            id_,\n            uint32(block.number),\n            UNINITIALIZED,\n            UNINITIALIZED\n        );\n        emit Add(msg.sender, id_);\n    }\n\n    // A `REMOVER` can scrub state mapping from an account.\n    // A malicious account MUST be banned rather than removed.\n    // Removal is useful to reset the whole process in case of some mistake.\n    function remove(address account_) external {\n        require(account_ != address(0), \"0_ADDRESS\");\n        require(hasRole(REMOVER, msg.sender), \"ONLY_REMOVER\");\n        delete(states[account_]);\n        emit Remove(account_);\n    }\n\n    // An `APPROVER` can review an added session ID and approve the account.\n    function approve(address account_) external {\n        require(account_ != address(0), \"0_ADDRESS\");\n        require(hasRole(APPROVER, msg.sender), \"ONLY_APPROVER\");\n        // In theory we should also check the `addedSince` is lte the current\n        // `block.number` but in practise no code path produces a future\n        // `addedSince`.\n        require(states[account_].addedSince > 0, \"NOT_ADDED\");\n        require(\n            states[account_].approvedSince == UNINITIALIZED,\n            \"PRIOR_APPROVE\"\n        );\n        require(\n            states[account_].bannedSince == UNINITIALIZED,\n            \"PRIOR_BAN\"\n        );\n        states[account_].approvedSince = uint32(block.number);\n        emit Approve(account_);\n    }\n\n    // A `BANNER` can ban an added OR approved account.\n    function ban(address account_) external {\n        require(account_ != address(0), \"0_ADDRESS\");\n        require(hasRole(BANNER, msg.sender), \"ONLY_BANNER\");\n        // In theory we should also check the `addedSince` is lte the current\n        // `block.number` but in practise no code path produces a future\n        // `addedSince`.\n        require(states[account_].addedSince > 0, \"NOT_ADDED\");\n        require(\n            states[account_].bannedSince == UNINITIALIZED,\n            \"PRIOR_BAN\"\n        );\n        states[account_].bannedSince = uint32(block.number);\n        emit Ban(account_);\n    }\n}"
    },
    "contracts/verify/VerifyFactory.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.6.12;\n\nimport { Factory } from \"../factory/Factory.sol\";\nimport { Verify } from \"./Verify.sol\";\n\n/// @title VerifyFactory\n/// @notice Factory for creating and deploying `Verify` contracts.\ncontract VerifyFactory is Factory {\n\n    /// @inheritdoc Factory\n    function _createChild(\n        bytes calldata data_\n    ) internal virtual override returns(address) {\n        (address admin_) = abi.decode(data_, (address));\n        Verify verify_ = new Verify(admin_);\n        return address(verify_);\n    }\n\n    /// Typed wrapper for `createChild` with admin address.\n    /// Use original `Factory` `createChild` function signature if function\n    /// parameters are already encoded.\n    ///\n    /// @param admin_ `address` of the `Verify` admin.\n    /// @return New `Verify` child contract address.\n    function createChild(address admin_) external returns(address) {\n        return this.createChild(abi.encode(admin_));\n    }\n}"
    },
    "contracts/tier/ERC20BalanceTier.sol": {
      "content": "// SPDX-License-Identifier: CAL\n\npragma solidity 0.6.12;\n\nimport { SafeMath } from \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport { TierUtil } from \"../libraries/TierUtil.sol\";\nimport { ValueTier } from \"./ValueTier.sol\";\nimport { ITier } from \"./ITier.sol\";\nimport \"./ReadOnlyTier.sol\";\n\n/// @title ERC20BalanceTier\n/// @notice `ERC20BalanceTier` inherits from `ReadOnlyTier`.\n///\n/// There is no internal accounting, the balance tier simply reads the balance\n/// of the user whenever `report` is called.\n///\n/// `setTier` always fails.\n///\n/// There is no historical information so each tier will either be `0x00000000`\n/// or `0xFFFFFFFF` for the block number.\n///\n/// @dev The `ERC20BalanceTier` simply checks the current balance of an erc20\n/// against tier values. As the current balance is always read from the erc20\n/// contract directly there is no historical block data.\n/// All tiers held at the current value will be 0x00000000 and tiers not held\n/// will be 0xFFFFFFFF.\n/// `setTier` will error as this contract has no ability to write to the erc20\n/// contract state.\n///\n/// Balance tiers are useful for:\n/// - Claim contracts that don't require backdated tier holding\n///   (be wary of griefing!).\n/// - Assets that cannot be transferred, so are not eligible for\n///   `ERC20TransferTier`.\n/// - Lightweight, realtime checks that encumber the tiered address\n///   as little as possible.\ncontract ERC20BalanceTier is ReadOnlyTier, ValueTier {\n    IERC20 public immutable erc20;\n\n    /// @param erc20_ The erc20 token contract to check the balance\n    /// of at `report` time.\n    /// @param tierValues_ 8 values corresponding to minimum erc20\n    /// balances for `Tier.ONE` through `Tier.EIGHT`.\n    constructor(IERC20 erc20_, uint256[8] memory tierValues_)\n        public\n        ValueTier(tierValues_)\n    {\n        erc20 = erc20_;\n    }\n\n    /// Report simply truncates all tiers above the highest value held.\n    /// @inheritdoc ITier\n    function report(address account_) public view override returns (uint256) {\n        return TierUtil.truncateTiersAbove(\n            uint(ITier.Tier.ZERO),\n            valueToTier(erc20.balanceOf(account_))\n        );\n    }\n}"
    },
    "contracts/tier/NeverTier.sol": {
      "content": "// SPDX-License-Identifier: CAL\n\npragma solidity 0.6.12;\n\nimport \"./ReadOnlyTier.sol\";\n\n/// @title NeverTier\n/// @notice `NeverTier` inherits from `ReadOnlyTier`.\n///\n/// Never returns any tier, i.e. `0xFFFFFFFF` for every address and tier.\n///\n/// @dev `NeverTier` is intended as a primitive for combining tier contracts.\n///\n/// As the name implies:\n/// - `NeverTier` is `ReadOnlyTier` and so can never call `setTier`.\n/// - `report` is always `uint256(-1)` as every tier is unobtainable.\ncontract NeverTier is ReadOnlyTier {\n    /// Every tier in the report is unobtainable.\n    /// @inheritdoc ITier\n    function report(address) public override view returns (uint256) {\n        return uint256(-1);\n    }\n}"
    },
    "contracts/tier/AlwaysTier.sol": {
      "content": "// SPDX-License-Identifier: CAL\n\npragma solidity 0.6.12;\n\nimport \"./ReadOnlyTier.sol\";\n\n/// @title AlwaysTier\n/// @notice `AlwaysTier` inherits from `ReadOnlyTier`.\n///\n/// Always returns every tier, i.e. `0x00000000` for every address and tier.\n///\n/// @dev `AlwaysTier` is intended as a primitive for combining tier contracts.\n///\n/// As the name implies:\n/// - `AlwaysTier` is `ReadOnlyTier` and so can never call `setTier`.\n/// - `report` is always `0x00000000` for every tier and every address.\ncontract AlwaysTier is ReadOnlyTier {\n    /// Every address is always every tier.\n    /// @inheritdoc ITier\n    function report(address) public override view returns (uint256) {\n        return 0;\n    }\n}"
    },
    "@openzeppelin/contracts/token/ERC1155/ERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"./IERC1155.sol\";\nimport \"./IERC1155MetadataURI.sol\";\nimport \"./IERC1155Receiver.sol\";\nimport \"../../GSN/Context.sol\";\nimport \"../../introspection/ERC165.sol\";\nimport \"../../math/SafeMath.sol\";\nimport \"../../utils/Address.sol\";\n\n/**\n *\n * @dev Implementation of the basic standard multi-token.\n * See https://eips.ethereum.org/EIPS/eip-1155\n * Originally based on code by Enjin: https://github.com/enjin/erc-1155\n *\n * _Available since v3.1._\n */\ncontract ERC1155 is Context, ERC165, IERC1155, IERC1155MetadataURI {\n    using SafeMath for uint256;\n    using Address for address;\n\n    // Mapping from token ID to account balances\n    mapping (uint256 => mapping(address => uint256)) private _balances;\n\n    // Mapping from account to operator approvals\n    mapping (address => mapping(address => bool)) private _operatorApprovals;\n\n    // Used as the URI for all token types by relying on ID substitution, e.g. https://token-cdn-domain/{id}.json\n    string private _uri;\n\n    /*\n     *     bytes4(keccak256('balanceOf(address,uint256)')) == 0x00fdd58e\n     *     bytes4(keccak256('balanceOfBatch(address[],uint256[])')) == 0x4e1273f4\n     *     bytes4(keccak256('setApprovalForAll(address,bool)')) == 0xa22cb465\n     *     bytes4(keccak256('isApprovedForAll(address,address)')) == 0xe985e9c5\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256,uint256,bytes)')) == 0xf242432a\n     *     bytes4(keccak256('safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)')) == 0x2eb2c2d6\n     *\n     *     => 0x00fdd58e ^ 0x4e1273f4 ^ 0xa22cb465 ^\n     *        0xe985e9c5 ^ 0xf242432a ^ 0x2eb2c2d6 == 0xd9b67a26\n     */\n    bytes4 private constant _INTERFACE_ID_ERC1155 = 0xd9b67a26;\n\n    /*\n     *     bytes4(keccak256('uri(uint256)')) == 0x0e89341c\n     */\n    bytes4 private constant _INTERFACE_ID_ERC1155_METADATA_URI = 0x0e89341c;\n\n    /**\n     * @dev See {_setURI}.\n     */\n    constructor (string memory uri_) public {\n        _setURI(uri_);\n\n        // register the supported interfaces to conform to ERC1155 via ERC165\n        _registerInterface(_INTERFACE_ID_ERC1155);\n\n        // register the supported interfaces to conform to ERC1155MetadataURI via ERC165\n        _registerInterface(_INTERFACE_ID_ERC1155_METADATA_URI);\n    }\n\n    /**\n     * @dev See {IERC1155MetadataURI-uri}.\n     *\n     * This implementation returns the same URI for *all* token types. It relies\n     * on the token type ID substitution mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\n     *\n     * Clients calling this function must replace the `\\{id\\}` substring with the\n     * actual token type ID.\n     */\n    function uri(uint256) external view override returns (string memory) {\n        return _uri;\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) public view override returns (uint256) {\n        require(account != address(0), \"ERC1155: balance query for the zero address\");\n        return _balances[id][account];\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOfBatch}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(\n        address[] memory accounts,\n        uint256[] memory ids\n    )\n        public\n        view\n        override\n        returns (uint256[] memory)\n    {\n        require(accounts.length == ids.length, \"ERC1155: accounts and ids length mismatch\");\n\n        uint256[] memory batchBalances = new uint256[](accounts.length);\n\n        for (uint256 i = 0; i < accounts.length; ++i) {\n            require(accounts[i] != address(0), \"ERC1155: batch balance query for the zero address\");\n            batchBalances[i] = _balances[ids[i]][accounts[i]];\n        }\n\n        return batchBalances;\n    }\n\n    /**\n     * @dev See {IERC1155-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        require(_msgSender() != operator, \"ERC1155: setting approval status for self\");\n\n        _operatorApprovals[_msgSender()][operator] = approved;\n        emit ApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC1155-isApprovedForAll}.\n     */\n    function isApprovedForAll(address account, address operator) public view override returns (bool) {\n        return _operatorApprovals[account][operator];\n    }\n\n    /**\n     * @dev See {IERC1155-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    )\n        public\n        virtual\n        override\n    {\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, _asSingletonArray(id), _asSingletonArray(amount), data);\n\n        _balances[id][from] = _balances[id][from].sub(amount, \"ERC1155: insufficient balance for transfer\");\n        _balances[id][to] = _balances[id][to].add(amount);\n\n        emit TransferSingle(operator, from, to, id, amount);\n\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\n    }\n\n    /**\n     * @dev See {IERC1155-safeBatchTransferFrom}.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    )\n        public\n        virtual\n        override\n    {\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: transfer caller is not owner nor approved\"\n        );\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            _balances[id][from] = _balances[id][from].sub(\n                amount,\n                \"ERC1155: insufficient balance for transfer\"\n            );\n            _balances[id][to] = _balances[id][to].add(amount);\n        }\n\n        emit TransferBatch(operator, from, to, ids, amounts);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Sets a new URI for all token types, by relying on the token type ID\n     * substitution mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\n     *\n     * By this mechanism, any occurrence of the `\\{id\\}` substring in either the\n     * URI or any of the amounts in the JSON file at said URI will be replaced by\n     * clients with the token type ID.\n     *\n     * For example, the `https://token-cdn-domain/\\{id\\}.json` URI would be\n     * interpreted by clients as\n     * `https://token-cdn-domain/000000000000000000000000000000000000000000000000000000000004cce0.json`\n     * for token type ID 0x4cce0.\n     *\n     * See {uri}.\n     *\n     * Because these URIs cannot be meaningfully represented by the {URI} event,\n     * this function emits no events.\n     */\n    function _setURI(string memory newuri) internal virtual {\n        _uri = newuri;\n    }\n\n    /**\n     * @dev Creates `amount` tokens of token type `id`, and assigns them to `account`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function _mint(address account, uint256 id, uint256 amount, bytes memory data) internal virtual {\n        require(account != address(0), \"ERC1155: mint to the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, address(0), account, _asSingletonArray(id), _asSingletonArray(amount), data);\n\n        _balances[id][account] = _balances[id][account].add(amount);\n        emit TransferSingle(operator, address(0), account, id, amount);\n\n        _doSafeTransferAcceptanceCheck(operator, address(0), account, id, amount, data);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_mint}.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function _mintBatch(address to, uint256[] memory ids, uint256[] memory amounts, bytes memory data) internal virtual {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        for (uint i = 0; i < ids.length; i++) {\n            _balances[ids[i]][to] = amounts[i].add(_balances[ids[i]][to]);\n        }\n\n        emit TransferBatch(operator, address(0), to, ids, amounts);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, address(0), to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens of token type `id` from `account`\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens of token type `id`.\n     */\n    function _burn(address account, uint256 id, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC1155: burn from the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, account, address(0), _asSingletonArray(id), _asSingletonArray(amount), \"\");\n\n        _balances[id][account] = _balances[id][account].sub(\n            amount,\n            \"ERC1155: burn amount exceeds balance\"\n        );\n\n        emit TransferSingle(operator, account, address(0), id, amount);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_burn}.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     */\n    function _burnBatch(address account, uint256[] memory ids, uint256[] memory amounts) internal virtual {\n        require(account != address(0), \"ERC1155: burn from the zero address\");\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, account, address(0), ids, amounts, \"\");\n\n        for (uint i = 0; i < ids.length; i++) {\n            _balances[ids[i]][account] = _balances[ids[i]][account].sub(\n                amounts[i],\n                \"ERC1155: burn amount exceeds balance\"\n            );\n        }\n\n        emit TransferBatch(operator, account, address(0), ids, amounts);\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning, as well as batched variants.\n     *\n     * The same hook is called on both single and batched variants. For single\n     * transfers, the length of the `id` and `amount` arrays will be 1.\n     *\n     * Calling conditions (for each `id` and `amount` pair):\n     *\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * of token type `id` will be  transferred to `to`.\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\n     * for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\n     * will be burned.\n     * - `from` and `to` are never both zero.\n     * - `ids` and `amounts` have the same, non-zero length.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    )\n        internal virtual\n    { }\n\n    function _doSafeTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    )\n        private\n    {\n        if (to.isContract()) {\n            try IERC1155Receiver(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {\n                if (response != IERC1155Receiver(to).onERC1155Received.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _doSafeBatchTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    )\n        private\n    {\n        if (to.isContract()) {\n            try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (bytes4 response) {\n                if (response != IERC1155Receiver(to).onERC1155BatchReceived.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _asSingletonArray(uint256 element) private pure returns (uint256[] memory) {\n        uint256[] memory array = new uint256[](1);\n        array[0] = element;\n\n        return array;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/IERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.2 <0.8.0;\n\nimport \"../../introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155 is IERC165 {\n    /**\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(address indexed operator, address indexed from, address indexed to, uint256[] ids, uint256[] values);\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids) external view returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(address from, address to, uint256[] calldata ids, uint256[] calldata amounts, bytes calldata data) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/IERC1155MetadataURI.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.2 <0.8.0;\n\nimport \"./IERC1155.sol\";\n\n/**\n * @dev Interface of the optional ERC1155MetadataExtension interface, as defined\n * in the https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155MetadataURI is IERC1155 {\n    /**\n     * @dev Returns the URI for token type `id`.\n     *\n     * If the `\\{id\\}` substring is present in the URI, it must be replaced by\n     * clients with the actual token type ID.\n     */\n    function uri(uint256 id) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../../introspection/IERC165.sol\";\n\n/**\n * _Available since v3.1._\n */\ninterface IERC1155Receiver is IERC165 {\n\n    /**\n        @dev Handles the receipt of a single ERC1155 token type. This function is\n        called at the end of a `safeTransferFrom` after the balance has been updated.\n        To accept the transfer, this must return\n        `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n        (i.e. 0xf23a6e61, or its own function selector).\n        @param operator The address which initiated the transfer (i.e. msg.sender)\n        @param from The address which previously owned the token\n        @param id The ID of the token being transferred\n        @param value The amount of tokens being transferred\n        @param data Additional data with no specified format\n        @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\n    */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    )\n        external\n        returns(bytes4);\n\n    /**\n        @dev Handles the receipt of a multiple ERC1155 token types. This function\n        is called at the end of a `safeBatchTransferFrom` after the balances have\n        been updated. To accept the transfer(s), this must return\n        `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n        (i.e. 0xbc197c81, or its own function selector).\n        @param operator The address which initiated the batch transfer (i.e. msg.sender)\n        @param from The address which previously owned the token\n        @param ids An array containing ids of each token being transferred (order and length must match values array)\n        @param values An array containing amounts of each token being transferred (order and length must match ids array)\n        @param data Additional data with no specified format\n        @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\n    */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    )\n        external\n        returns(bytes4);\n}\n"
    },
    "@openzeppelin/contracts/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts may inherit from this and call {_registerInterface} to declare\n * their support of an interface.\n */\nabstract contract ERC165 is IERC165 {\n    /*\n     * bytes4(keccak256('supportsInterface(bytes4)')) == 0x01ffc9a7\n     */\n    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\n\n    /**\n     * @dev Mapping of interface ids to whether or not it's supported.\n     */\n    mapping(bytes4 => bool) private _supportedInterfaces;\n\n    constructor () internal {\n        // Derived contracts need only register support for their own interfaces,\n        // we register support for ERC165 itself here\n        _registerInterface(_INTERFACE_ID_ERC165);\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     *\n     * Time complexity O(1), guaranteed to always use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) public view override returns (bool) {\n        return _supportedInterfaces[interfaceId];\n    }\n\n    /**\n     * @dev Registers the contract as an implementer of the interface defined by\n     * `interfaceId`. Support of the actual ERC165 interface is automatic and\n     * registering its interface id is not required.\n     *\n     * See {IERC165-supportsInterface}.\n     *\n     * Requirements:\n     *\n     * - `interfaceId` cannot be the ERC165 invalid interface (`0xffffffff`).\n     */\n    function _registerInterface(bytes4 interfaceId) internal virtual {\n        require(interfaceId != 0xffffffff, \"ERC165: invalid interface id\");\n        _supportedInterfaces[interfaceId] = true;\n    }\n}\n"
    },
    "@openzeppelin/contracts/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    }
  },
  "settings": {
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 100000
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers"
        ],
        "": [
          "ast"
        ]
      }
    }
  }
}
